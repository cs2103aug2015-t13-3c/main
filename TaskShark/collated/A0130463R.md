# A0130463R
###### TaskSharkInternal\Command.cpp
``` cpp

#include "stdafx.h"
#include "History.h"
#include "Logic.h"

bool		TS::firstLoad = true;
std::string TS::MESSAGE_WELCOME = "Welcome to TaskShark!";

std::string TS::COMMAND_ADD = "add";
std::string TS::COMMAND_DELETE = "delete";
std::string TS::COMMAND_MODIFY = "modify";
std::string TS::COMMAND_PICK_RESERVE = "pick";
std::string TS::COMMAND_SEARCH = "search";
std::string TS::COMMAND_MARKDONE = "done";
std::string TS::COMMAND_UNMARKDONE = "notdone";
std::string TS::COMMAND_UNDO = "undo";
std::string TS::COMMAND_REDO = "redo";
std::string TS::COMMAND_VIEW = "view";
std::string TS::COMMAND_VIEW_HOME = "home";	 // For easy access to default view
std::string TS::COMMAND_VIEW_HOME_TS = "ts"; // For easy access to default view
std::string TS::COMMAND_CLEAR_ALL = "clear";
std::string TS::COMMAND_DISPLAY_ALL = "display";
std::string TS::COMMAND_LOAD = "load";
std::string TS::COMMAND_SAVE = "save";
std::string TS::COMMAND_SET = "set";
std::string TS::COMMAND_EXIT = "exit";

//==================================================
//                      COMMAND
//==================================================

//========== COMMAND : PUBLIC METHODS ==============

Command::Command(CommandType newCmd, std::string rawInput) {
	logger = TsLogger::getInstance();
	cmd = newCmd;
	userInput = rawInput;
}

Command::~Command() {}

CommandType Command::getCommand() {
	return cmd;
}

std::string Command::getUserInput() {
	return userInput;
}

std::vector<Task> Command::getTaskStore() {
	return taskStore;
}

std::vector<Task> Command::getCurrentView() {
	return currentView;
}

std::vector<Task>* Command::getCurrentViewPtr() {
	return &currentView;
}

int Command::getSize() {
	return taskStore.size();
}

void Command::clearTaskStore() {
	IO* io = IO::getInstance();
	taskStore.clear();
	currentView.clear();
	remove(io->getFilePath().c_str());
	return;
}

// Virtual functions
void Command::execute() {}

void Command::undo() {
	throw std::runtime_error("Action cannot be undone");
}

//================ COMMAND : PROTECTED METHODS ==================

const std::string Command::ERROR_INDEX_OUT_OF_BOUNDS = "Invalid index";
const std::string Command::ERROR_TASK_START_LATER_THAN_TASK_END = "Start of task is later than end of task";
const std::string Command::ERROR_INVALID_ACTION_IN_FREE_PERIOD_MODE = "Action cannot be performed when viewing free periods";

std::vector<Task> Command::taskStore;
std::vector<Task> Command::currentView;
bool			  Command::isFreePeriodMode;
// Initialises the corresponding iterators with the guiID
// guiID is the ID seen on GUI, not the unique task ID
// Use for in-place insertion / deletion for undo methods
void Command::initialiseIteratorsFromGuiID(int guiID) {
	matchIndex(guiID,currViewIter,taskStoreIter);
	currViewPos = currViewIter - currentView.begin();
	taskStorePos = taskStoreIter - taskStore.begin();
}

// Initialises the corresponding iterators with the uniqueID
// uniqueID is not the ID seen on GUI
// Use for constrcutors to undo
void Command::initialiseIteratorsFromUniqueID() {
	taskStoreIter = matchTaskStoreIndex(uniqueID);
	if(currentView.size() > 0) {
		currViewIter = matchCurrentViewUniqueID(uniqueID);
		currViewPos = currViewIter - currentView.begin();
		if((unsigned int)currViewPos >= currentView.size()) {
			currViewPos = -1;
		}
	} else {
		currViewPos = -1;
	}

	taskStorePos = taskStoreIter - taskStore.begin();
}

// Get iterators from their vector index
// Use for in-place insertion / deletion for undo methods
// Don't use previous iterator values, because it may go out-of-bounds
void Command::getIterator() {
	currViewIter = currentView.begin() + currViewPos;
	taskStoreIter = taskStore.begin() + taskStorePos;
}

// If end date is later than start date, start/end time should not matter
bool Command::isDateLogical(Task task) {
	if (   (task.getStartDate() >  task.getEndDate())
		|| (task.getStartDate() == task.getEndDate() && task.getStartTime() > task.getEndTime())) {
			return false;
	}
	return true;
}

// Sorts floating tasks to be at the bottom
void Command::sortFloating(std::vector<Task> &taskVector) {
	std::vector<Task>::iterator i;
	std::vector<Task>::iterator j;
	std::vector<Task>::iterator k;
	Task tempTask;

	// In-place sorting
	i = taskVector.begin();	// Points to start of unsorted part
	k = taskVector.end();	// Points to end of unsorted part
	while (i < k) {
		if (i->getType() == FLOATING) {
			tempTask = *i;
			for (j = i+1; j != taskVector.end(); ++j) {
				std::swap(*j, *(j-1)); 
			}
			*(j-1) = tempTask;
			if (k == taskVector.begin()) {
				break;
			} else {
				--k;
			}
		} else {
			++i;
		}
	}
}

// Sorts Event tasks to be at the top
void Command::sortEvent(std::vector<Task> &taskVector) {
	std::vector<Task>::iterator i;
	std::vector<Task>::iterator j;
	std::vector<Task>::iterator k;
	Task tempTask;

	if(taskVector.size() == 0) {
		return;
	}

	// In-place sorting
	i = taskVector.end()-1;	// Points to start of unsorted part
	k = taskVector.begin();	// Points to end of unsorted part
	while (i > k) {
		if (i->getType() == EVENT) {
			tempTask = *i;
			for (j = i; j != taskVector.begin(); --j) {
				std::swap(*j, *(j-1)); 
			}
			*j = tempTask;
			if (k == taskVector.end()) {
				break;
			} else {
				++k;
			}
		} else {
			--i;
		}
	}

	sortDate(taskVector.begin(),k+1);
}

void Command::viewPeriod(int startDate, int startTime, int endDate, int endTime) {
	std::vector<Task> periodStore;
	currentView.clear();
	periodStore = taskStore;
	sortDefault(periodStore);
	removeDoneTasks(periodStore);
	std::vector<Task>::iterator iter = periodStore.begin();

	for (iter = periodStore.begin(); iter != periodStore.end(); ++iter) {
		if (iter->getType() == FLOATING) {
			currentView.push_back(*iter);
		} else {
			if ((iter->getStartDate() > startDate) && (iter->getStartDate() < endDate)) {
				currentView.push_back(*iter);
			}

			// If date is the same, further filter using time in the date
			if (iter->getStartDate() == startDate) {
				if (iter->getStartTime() >= startTime) {
					currentView.push_back(*iter);
				}
			}

			if (iter->getStartDate() == endDate) {
				if (iter->getStartTime() <= endTime) {
					currentView.push_back(*iter);				
				}
			}
		}
	}
}

// Sorts tasks by increasing order of start date
void Command::sortDate(std::vector<Task> &taskVector) {
	std::vector<Task>::iterator i;
	std::vector<Task>::iterator j;

	// Sorts date after time to ensure date is accurately sorted
	// Uses bubblesort algorithm
	for (i = taskVector.end(); i != taskVector.begin(); --i) {
		for (j = taskVector.begin()+1; j != i; ++j) {
			if ((j-1) -> getStartDate() > j -> getStartDate()) {
				std::swap(*j, *(j-1));
			}
		}
	}
}

// sortDate for specific portions of the Task vector only
// start: iterator to first element to sort
// end: iterator to last element to sort + 1 [just like .end()]
void Command::sortDate(std::vector<Task>::iterator start, std::vector<Task>::iterator end) {
	std::vector<Task>::iterator i;
	std::vector<Task>::iterator j;
	
	// Sorts date after time to ensure date is accurately sorted
	// Uses bubblesort algorithm
	for (i = end; i != start; --i) {
		for (j = start+1; j != i; ++j) {
			if ((j-1) -> getStartDate() > j -> getStartDate()) {
				std::swap(*j, *(j-1));
			}
		}
	}
}

void Command::sortTime(std::vector<Task> &taskVector) {
	std::vector<Task>::iterator i;
	std::vector<Task>::iterator j;
	std::vector<Task>::iterator smallest;

	// Uses selection sort algorithm for startTime
	for (i = taskVector.begin(); i != taskVector.end(); ++i) {
		assert((i->getStartDate() < i->getEndDate()) || 
			((i->getStartDate() == i->getEndDate()) && (i->getStartTime() <= i->getEndTime())));
		smallest = i;
		for (j = i+1; j != taskVector.end(); ++j) {
			if (j->getStartTime() < smallest->getStartTime()) {
				smallest = j;
			}
		}
		std::swap(*i, *smallest);
	}	
}

// Sorts in increasing order of dates (except for floating tasks, which are at the bottom)
// Use this before returning to UI for display
void Command::sortDefault(std::vector<Task> &taskVector) {
	sortTime(taskVector);
	sortDate(taskVector);	
	sortFloating(taskVector);
	sortEvent(taskVector);
}

void Command::removeDoneTasks(std::vector<Task> &taskVector) {
	std::vector<Task>::iterator i = taskVector.begin();

	while (i != taskVector.end()) {
		if (i->getDoneStatus() == true) {
			i = taskVector.erase(i);
		} else {
			++i;
		}
	}
}

void Command::removeTaskType(std::vector<Task> &taskVector, TaskType type) {
	std::vector<Task>::iterator i = taskVector.begin();

	while (i != taskVector.end()) {
		if (i->getType() == type) {
			i = taskVector.erase(i);
		} else {
			++i;
		}
	}
}

// Adds a period where there are no undone tasks on hand to freeSlots
void Command::addPeriod(std::vector<Task> &taskVector, int startDate, int startTime, int endDate, int endTime) {
	Task freePeriod;

	freePeriod.setStartDate(startDate);
	freePeriod.setStartTime(startTime);
	freePeriod.setEndDate(endDate);
	freePeriod.setEndTime(endTime);

	taskVector.push_back(freePeriod);
}

// Set currentView to be the same as taskStore
bool Command::updateCurrView() {
	currentView = taskStore;
	return true;
}

// Updates only the modified task on the UI 
void Command::updateViewIter() {
	*currViewIter = *taskStoreIter;
	return;
}

// Switch back to default view:
// Shows only uncompleted items from today, tomorrow and the day after
// Tasks are shown in the following order: Events, Todo, Float
void Command::defaultView() {
	sortDefault(taskStore);
	int today = Utilities::getLocalDay() + Utilities::getLocalMonth()*100 + Utilities::getLocalYear()*10000;
	// TODO: Handle dates at end of month
	viewPeriod(today,TIME_NOT_SET,today+2,2359);
	return;
}

void Command::matchIndex(int index, std::vector<Task>::iterator &currIter,
						 std::vector<Task>::iterator &taskIter) {
							 if (index == 0) {
								 index = Task::lastEditID;
							 }
							 if (isValidIndex(index)) {	
								 currIter = matchCurrentViewIndex(index);
								 index = currIter->getID();
								 taskIter = matchTaskStoreIndex(index);
							 } else {
								 logger->log(WARN,"Invalid index: " + std::to_string(index));
								 throw std::runtime_error(ERROR_INDEX_OUT_OF_BOUNDS);
							 }
}

bool Command::isValidIndex(int index) {
	if (index <1 || index > (int)currentView.size()) {
		return false;
	} 
	return true;
} 

// Index is ID as seen on GUI
std::vector<Task>::iterator Command::matchCurrentViewIndex(int index) {
	assert(index >0 && index <= (int)currentView.size());
	std::vector<Task>::iterator iter = currentView.begin();
	for (int i=1; i< index; ++i) {
		++iter;
	}
	return iter;
}

// Index is uniqueID
std::vector<Task>::iterator Command::matchTaskStoreIndex(int index) {
	std::vector<Task>::iterator iter = taskStore.begin();
	while (iter->getID() != index && iter != taskStore.end()) {
		++iter;
	}
	assert(iter != taskStore.end());
	return iter;
}

// Index is uniqueID
std::vector<Task>::iterator Command::matchCurrentViewUniqueID(int ID) {
	std::vector<Task>::iterator iter = currentView.begin();
	while (iter != currentView.end() && iter->getID() != ID) {
		++iter;
	}
	return iter;
}

std::string Command::getMessage() {
	return "";
}

//==================================================
//                        ADD
//==================================================

//============== ADD : PUBLIC METHODS ===============

Add::Add(Task task, std::string restOfCommand) : Command(ADD) {
	isFreePeriodMode = false;
	newTask = task;
	currViewID = 0;
	isOverlap = false;
	invalidDateTimeString = restOfCommand;
	uniqueID = task.getID();
}

Add::~Add() {}

Task Add::getNewTask() {
	return newTask;
}

void Add::execute() {
	doAdd();
	Task::lastEditID = newTask.getID();
	defaultView();
	Logic::setHomeMode();
}

// Add must have executed before undoing,
// otherwise currViewID will not be updated
void Add::undo() {
	isFreePeriodMode = false;
	Delete taskToDelete(uniqueID,true);
	taskToDelete.execute();
	Task::lastEditID = 0;
}

std::string Add::getMessage() {
	if (isOverlap) {
		msg = "Task added overlaps with existing task!";
	} else if (invalidDateTimeString != "") {
		msg = "Task added contains invalid date/time: " + invalidDateTimeString;
	} else {
		msg = "\"" + newTask.getName() + "\" added";
	}
	return msg;
}

//============== ADD : PRIVATE METHODS ===============

bool Add::doAdd() {
	if (isDateLogical(newTask) == false) {
		throw std::runtime_error(ERROR_TASK_START_LATER_THAN_TASK_END);
	}

	updateCurrView();
	checkOverlap();
	taskStore.push_back(newTask);
	currentView.push_back(newTask);
	currViewID = currentView.size();

	return true;
}

void Add::checkOverlap() {
	std::vector<Task> taskStoreCopy = taskStore;
	removeDoneTasks(taskStoreCopy);
	removeTaskType(taskStoreCopy, FLOATING);
	sortDefault(taskStoreCopy);

	std::vector<Task>::iterator iter = taskStoreCopy.begin();

	while (iter != taskStoreCopy.end()) {
		// Will not overlap if start of task added is later than end of task alr present in list
		if ((newTask.getStartDate() > (iter->getEndDate()) || 
			((newTask.getStartDate() == iter->getEndDate()) && (newTask.getStartTime() >= iter->getEndTime())))) {
				++iter;
		} else if ((newTask.getEndDate() < (iter->getStartDate()) || 
			((newTask.getEndDate() == iter->getStartDate()) && (newTask.getEndTime() <= iter->getStartTime())))) {
				++iter;
		} else {
			isOverlap = true;
			break;
		}
	}
}
//==================================================
//                       DELETE
//==================================================

//============ DELETE : PUBLIC METHODS =============

Delete::Delete(int currentViewID) : Command(DELETE) {
	if (isFreePeriodMode) {
		throw std::runtime_error(ERROR_INVALID_ACTION_IN_FREE_PERIOD_MODE);
	} else {
		deleteID = currentViewID;
		initialiseIteratorsFromGuiID(deleteID); // Sets taskStoreIter and currViewIter, using currentViewID
		setUndoDeleteInfo();
	}
}

//Overloaded Delete constructor used for undo only
Delete::Delete(int taskID, bool undo) : Command(DELETE) {
	uniqueID = taskID;
	initialiseIteratorsFromUniqueID();
}

Delete::~Delete() {}

int Delete::getDeleteID() {
	return deleteID;
}

void Delete::execute() {
	doDelete();
	Task::lastEditID = 0;
	defaultView();
	Logic::setHomeMode();
}

// Adds the deleted task back to the exact location it was before
void Delete::undo() {
	isFreePeriodMode = false;
	if ((unsigned int)taskStorePos < taskStore.size()) {
		taskStore.insert(taskStore.begin() + taskStorePos,taskToBeDeleted);
	} else {
		taskStore.push_back(taskToBeDeleted);
	}
	Task::lastEditID = taskToBeDeleted.getID();

	/*
	// For in-place undoing, if view is not set back to default
	if ((unsigned int)currViewPos < currentView.size()) {
	currentView.insert(currentView.begin() + currViewPos,taskToBeDeleted);
	} else {
	currentView.push_back(taskToBeDeleted);
	}
	*/
	defaultView();
	Logic::setHomeMode();
}

std::string Delete::getMessage() {
	return("\"" + taskToBeDeleted.getName() + "\"" + " deleted");
}

//============= DELETE : PRIVATE METHODS ===========

void Delete::doDelete() {
	taskStore.erase(taskStoreIter);
}

void Delete::setUndoDeleteInfo() {
	taskToBeDeleted = *currViewIter;
}

//==================================================
//                       MODIFY
//==================================================

//============= MODIFY : PUBLIC METHODS ============

Modify::Modify(int taskID, bool isModifyFloating) : Command(MODIFY) {
	if (isFreePeriodMode) {
		throw std::runtime_error(ERROR_INVALID_ACTION_IN_FREE_PERIOD_MODE);
	} else {
		modifyID = taskID;
		isSetFloating = isModifyFloating;
		initialiseIteratorsFromGuiID(modifyID);
		originalTask = *currViewIter;
	}
}

Modify::Modify(int taskID, std::vector<FieldType> fields,
			   Task task, std::string restOfInput) : Command(MODIFY) {
				   if (isFreePeriodMode) {
					   throw std::runtime_error(ERROR_INVALID_ACTION_IN_FREE_PERIOD_MODE);
				   } else {
					   modifyID = taskID;
					   isSetFloating = false;
					   fieldsToModify = fields;
					   tempTask = task;
					   invalidDateTimeString = restOfInput;
					   initialiseIteratorsFromGuiID(modifyID);
					   originalTask = *currViewIter;
				   }
}

Modify::Modify(CommandType pick) : Command(pick) {}

Modify::~Modify() {}

int Modify::getModifyID() {
	return modifyID;
}

std::vector<FieldType> Modify::getFieldsToModify() {
	return fieldsToModify;
}

Task Modify::getTempTask() {
	return tempTask;
}

void Modify::execute() {	
	uniqueID = originalTask.getID();
	initialiseIteratorsFromUniqueID();

	if (isSetFloating) {
		taskStoreIter->setType(FLOATING);
		taskStoreIter->resetDatesAndTimes();		
	} else {
		doModify();
		updateTaskTypes();
	}
	updateViewIter();
	sortDefault(taskStore);
	sortDefault(currentView);	
	Task::lastEditID = originalTask.getID();
	//defaultView();
}

void Modify::undo() {
	isFreePeriodMode = false;
	initialiseIteratorsFromUniqueID();
	*taskStoreIter = originalTask;
	if(currViewPos != -1) {
		*currViewIter = originalTask;
	}

	sortDefault(taskStore);
	sortDefault(currentView);
	initialiseIteratorsFromUniqueID();
	Task::lastEditID = originalTask.getID();
}

std::string Modify::getMessage() {
	if (invalidDateTimeString != "") {
		msg = "Task added contains invalid date/time: " + invalidDateTimeString;
	} else {
		msg = "successfully modified!";
	}
	return msg;
}

//============= MODIFY : PRIVATE METHODS ===========

void Modify::doModify() {
	std::vector<FieldType>::iterator fieldIter;
	bool isTODO = false;
	bool isTODOreserve = false;
	bool isStartTimeSet = false;
	bool isEndTimeSet = false;

	if (!isDateLogical(tempTask)) {
		throw std::runtime_error(ERROR_TASK_START_LATER_THAN_TASK_END);
	} else {
		if (tempTask.getType() == EVENT) {
			taskStoreIter->setType(EVENT);
		}
		if (tempTask.getReserveType() == EVENT) {
			taskStoreIter->setReserveType(EVENT);
		}

		for (fieldIter = fieldsToModify.begin(); fieldIter != fieldsToModify.end(); ++fieldIter) {
			switch (*fieldIter) {
			case NAME:
				taskStoreIter->setName(tempTask.getName());			
				break;
			case LABELS_ADD:
				taskStoreIter->addLabels(tempTask.getLabels());
				break;
			case LABELS_DELETE:
			case LABELS_CLEAR:
				if (tempTask.getLabelsToDelete().empty()) {
					taskStoreIter->clearLabels();
				} else {
					taskStoreIter->deleteLabels(tempTask.getLabelsToDelete());
				}
				break;
			case PRIORITY_SET:
				taskStoreIter->setPriority();
				break;
			case PRIORITY_UNSET:
				taskStoreIter->unsetPriority();
				break;
			case START_DATE:
				taskStoreIter->setStartDate(tempTask.getStartDate());
				if(tempTask.getType() == EVENT) {
					taskStoreIter->setEndDate(taskStoreIter->getStartDate());
				}
				break;
			case START_TIME:
				taskStoreIter->setStartTime(tempTask.getStartTime());
				if ((fieldIter+1 != fieldsToModify.end()) && (fieldIter+2 != fieldsToModify.end())
					&& (*(fieldIter+2) == START_TIME)) {	// Accounts for events that modifies endTime
						*(fieldIter+2) = END_TIME;
				}
				isStartTimeSet = true;
				break;
			case END_DATE:
				taskStoreIter->setEndDate(tempTask.getEndDate());
				break;
			case END_TIME:
				if (taskStoreIter->getEndDate() == DATE_NOT_SET) {
					taskStoreIter->setEndDate(tempTask.getStartDate());
				}
				taskStoreIter->setEndTime(tempTask.getEndTime());
				isEndTimeSet = true;
				break;
			case TODO_DATE:
				isTODO = true;
				taskStoreIter->setEndDate(tempTask.getEndDate());
				taskStoreIter->setEndTime(tempTask.getEndTime());
				break;
			case TODO_TIME:
				isTODO = true;
				isEndTimeSet = true;
				taskStoreIter->setEndTime(tempTask.getEndTime());
				break;
			case RESERVE_START_DATE:
				taskStoreIter->addReserveStartDate(tempTask.getReserveStartDate());
				break;
			case RESERVE_START_TIME:
				taskStoreIter->addReserveStartTime(tempTask.getReserveStartTime());
				break;
			case RESERVE_END_DATE:
				taskStoreIter->addReserveEndDate(tempTask.getReserveEndDate());
				break;
			case RESERVE_END_TIME:
				taskStoreIter->addReserveEndTime(tempTask.getReserveEndTime());
				break;
			case RESERVE_TODO_DATE:
				isTODOreserve = true;
				taskStoreIter->addReserveEndDate(tempTask.getEndDate());
				break;
			case RESERVE_TODO_TIME:
				isTODOreserve = true;
				taskStoreIter->addReserveEndTime(tempTask.getEndTime());
				break;
			case RESERVE:
				break;
			case INVALID_FIELD:
				throw std::runtime_error("Error in fetching field name"); 
			}
		}
		if (isTODO) {
			taskStoreIter->setType(TODO);
			taskStoreIter->setStartDate(taskStoreIter->getEndDate());
			if (isStartTimeSet) {
				taskStoreIter->setEndTime(taskStoreIter->getStartTime());	
			} else if (isEndTimeSet) {
				taskStoreIter->setStartTime(taskStoreIter->getEndTime());		
			}
		}
		if (isTODOreserve) {
			taskStoreIter->setReserveType(TODO);
			taskStoreIter->addReserveStartDate(taskStoreIter->getReserveEndDate());
			taskStoreIter->addReserveStartTime(taskStoreIter->getReserveEndTime());
		}
	}
}

// If start date == 0 && end date == 0: FLOATING
// If end date == start date: TODO
// All others: EVENTS
void Modify::updateTaskTypes() {
	if (!updateFLOATING()) {
		if (!updateTODO()) {
			updateEVENT();
		}
	}
}

bool Modify::updateFLOATING() {
	if (taskStoreIter->getStartDate()==DATE_NOT_SET && taskStoreIter->getStartTime()==TIME_NOT_SET
		&& taskStoreIter->getEndDate()==DATE_NOT_SET && taskStoreIter->getEndTime()==TIME_NOT_SET) {
			taskStoreIter->setType(FLOATING);
			return true;
	}
	return false;
}

bool Modify::updateTODO() {
	if (taskStoreIter->getStartDate() == taskStoreIter->getEndDate()
		&& taskStoreIter->getStartTime() == taskStoreIter->getEndTime()) {
			taskStoreIter->setType(TODO);
			return true;
	}
	return false;
}

bool Modify::updateEVENT() {
	taskStoreIter->setType(EVENT);
	return true;
}

// Moves modified back to previous position before executing
// In case sequence was swapped during sorting
/*
void Modify::moveToPrevPos() {
std::vector<Task>::iterator preCurrViewIter;
Task tempTask = *currViewIter;
currentView.erase(currViewIter);

preCurrViewIter = currentView.begin() + prevCurrPos;
currentView.insert(preCurrViewIter, tempTask);
}
*/

```
###### TaskSharkInternal\History.cpp
``` cpp

#include "stdafx.h"
#include "History.h"

History* History::theOne = new History();

std::vector<Command*> History::commandHistory;
std::vector<Command*> History::redoHistory;

History::History() {
	commandHistory.clear();
	redoHistory.clear();
}

History::~History() {}

//========== PUBLIC METHODS ==========

History* History::getInstance() {
	return theOne;
}

int History::getUndoSize() {
	return commandHistory.size();
}

// Add new command into History stack
void History::add(Command *cmd) {
	// cmd.execute();

	if(checkUndoableCommand(cmd)) {
		commandHistory.push_back(cmd);
		redoHistory.clear();
	}
}

// Undo most recent command in History stack
void History::undo() {
	if (commandHistory.size() == 0) {
		throw std::runtime_error("Nothing to undo");
	} else {
		Command* cmdToUndo = commandHistory.back();
		cmdToUndo->undo();
		redoHistory.push_back(cmdToUndo);
		commandHistory.pop_back();
	}
	return;
}

// Redo most recent undone action in redo stack
void History::redo() {
	if (redoHistory.size() == 0) {
		throw std::runtime_error("Nothing to redo");
	} else {
		Command* cmdToRedo = redoHistory.back();
		cmdToRedo->execute();
		commandHistory.push_back(cmdToRedo);
		redoHistory.pop_back();
	}
	return;
}

void History::clearHistory() {
	commandHistory.clear();
	redoHistory.clear();
}

bool History::checkUndoableCommand(Command* cmd) {
	CommandType type = cmd->getCommand();
	if(type == VIEW || type == SEARCH || type == POWERSEARCH || type == DISPLAY_ALL) {
		return false;
	} else {
		return true;
	}
}
```
###### TaskSharkInternal\History.h
``` h

#ifndef HISTORY_H_
#define HISTORY_H_

// Holds a stack of executed commands
class History {
private:
	static History* theOne; // Singleton
	History();

	static std::vector<Command*> commandHistory;
	static std::vector<Command*> redoHistory;

	bool checkUndoableCommand(Command* cmd);

public:
	static History* getInstance();
	~History();
	int getUndoSize();

	void add(Command *cmd);
	void undo();
	void redo();
	void clearHistory();
};

#endif
```
###### TaskSharkInternal\IO.cpp
``` cpp

#include "stdafx.h"
#include "IO.h"

// TODO: Refactor IO.cpp - remove repeated file names

using namespace rapidjson;

std::string IO::filePath = "mytasks.txt";
const std::string IO::configPath = ".tsconfig";

IO* IO::theOne = new IO();

IO::IO() {
	TsLogger::getInstance()->log(SYS,"IO instantiated");
	std::ifstream TSconfig(configPath);
	TSconfig >> filePath;
	loadWelcomeMessage(TSconfig);
	loadCustomCommands(TSconfig);
	TSconfig.close();
}

IO::~IO() {}

//==================================================
//                   PUBLIC METHODS
//==================================================

// TODO: Handle empty file / improper content exceptions

IO* IO::getInstance() {
	return theOne;
}

std::string IO::getFilePath() {
	return filePath;
}

// Note: Directory must already exist
// Returns false if unable to set file path
bool IO::setFilePath(std::string newFilePath, std::vector<Task> taskVector, bool isRemovePrevFile) {
	if (saveFile(newFilePath,taskVector)) {
		if (isRemovePrevFile) {
			remove(filePath.c_str());
		}
		filePath = newFilePath;
		return true;
	}
	return false;
}

// Loads file and extracts JSON text into a task vector
// Throws an assert() if file contents are invalid
std::vector<Task> IO::loadFile(std::string fileName, bool isOverwriteLoadFile) {
	std::ifstream inputFile(fileName);
	if (!fileIsOpen(inputFile)) {
		throw std::runtime_error("File does not exist");
	}

	std::string inputFileString((std::istreambuf_iterator<char>(inputFile)),
		std::istreambuf_iterator<char>());
	const char* inputFileText = inputFileString.c_str();

	Document document;
	document.Parse(inputFileText);
	assert(document.IsObject());
	assert(document["TaskShark Items"].IsArray());
	Value& item = document["TaskShark Items"];

	std::vector<Task> taskVector;
	if (item.Size() > 0) {
		for (SizeType i = 0; i < item.Size(); i++) {
			Task newTask = extractTaskFromJsonObject(item[i]);
			taskVector.push_back(newTask);
		}
		initialiseRunningCount(taskVector);
	}

	inputFile.close();
	if (isOverwriteLoadFile) {
		filePath = fileName;
	}
	return taskVector;
}

bool IO::saveFile(std::string fileName, std::vector<Task> taskVector) {
	remove(fileName.c_str());
	std::ofstream newfile(fileName);

	if (!fileIsOpen(newfile)) {
		return false;
	}

	initialiseJsonText(newfile);

	for (unsigned int i = 0; i < taskVector.size(); i++) {
		Task task = taskVector[i];
		writeTaskIntoJsonFormat(newfile,task);

		if (i+1 < taskVector.size()) {
			newfile << "\t\t,\n";
		}
	}

	closeJsonText(newfile);
	setLastSavedLocation(fileName);

	newfile.close();
	return true;
}

/*
bool IO::changeSourceFileLocation (std::string newFileLocation) {
std::string systemRoot;
systemRoot = getenv ("systemroot");

std::string newFullPath= systemRoot + "\\" + newFileLocation;
const char* newFullPathName = newFullPath.c_str();

return PathIsDirectory(newFullPathName);
}
*/

//==================================================
//                   PRIVATE METHODS
//==================================================

// Records down last saved location as .TSconfig file
// for IO to find where to load when it launches
void IO::setLastSavedLocation(std::string fileName) {
	remove(configPath.c_str());
	std::ofstream lastSaved(configPath);
	lastSaved << fileName << std::endl;

	saveWelcomeMessage(lastSaved);
	saveCustomCommands(lastSaved);
	lastSaved.close();
}

Task IO::extractTaskFromJsonObject(Value& item) {
	Task newTask;

	try {
		extractName(newTask, item);
		extractType(newTask, item);
		extractID(newTask, item);
		extractLabel(newTask, item);
		extractDone(newTask, item);
		extractPriority(newTask, item);
		extractStartDate(newTask, item);
		extractStartTime(newTask, item);
		extractEndDate(newTask, item);
		extractEndTime(newTask, item);
	} catch (std::string error) {
		throw std::runtime_error("Error occured: " + error);
	}

	return newTask;
}

void IO::writeTaskIntoJsonFormat(std::ofstream &newFile, Task task) {
	newFile << insertOpenParanthese();

	newFile << writeNameAttribute(task);
	newFile << writeTypeAttribute(task);
	newFile << writeIDAttribute(task);
	newFile << writeLabelAttribute(task) << "\n";
	newFile << writeIsDoneAttribute(task);
	newFile << writeIsPriorityAttribute(task) << "\n";
	newFile << writeStartDateAttribute(task);
	newFile << writeStartTimeAttribute(task) << "\n";
	newFile << writeEndDateAttribute(task);
	newFile << writeEndTimeAttribute(task);

	newFile << insertCloseParanthese();
	return;
}

//========== Extract Task Attribute Methods ==========

void IO::extractName(Task &newTask, Value &item) {
	std::string name = item["name"].GetString();
	bool success = newTask.setName(name);

	if (!success) {
		throw std::runtime_error("NameNotFound");
	}
}

void IO::extractType(Task &newTask, Value &item) {
	std::string typeString = item["type"].GetString();
	TaskType type = Utilities::stringToTaskType(typeString);
	bool success = newTask.setType(type);

	if (!success) {
		throw std::runtime_error("TypeNotFound");
	}
}

void IO::extractID(Task &newTask, Value &item) {
	int ID = item["uniqueID"].GetInt();
	bool success = newTask.setID(ID);

	if (!success) {
		throw std::runtime_error("IDNotFound");
	}
}

void IO::extractLabel(Task &newTask, Value &item) {
	int arraySize = item["label"].Size();
	std::vector<std::string> labels;

	for (int i = 0; i < arraySize; i++) {
		labels.push_back(item["label"][i].GetString());
	}
	bool success = newTask.addLabels(labels);

	if (!success) {
		throw std::runtime_error("LabelNotFound");
	}
}

void IO::extractDone(Task &newTask, Value &item) {
	bool isDone = item["isDone"].GetBool();
	// bool success = false;
	if (isDone) {
		newTask.markDone();
	}

	// TODO: how to throw exception for GeTSool
	/*
	if (!success) {
	throw "IDNotFound";
	}
	*/
}

void IO::extractPriority(Task &newTask, Value &item) {
	bool isPriority = item["isPriority"].GetBool();
	// bool success = false;
	if (isPriority) {
		newTask.setPriority();
	}

	// TODO: how to throw exception for GeTSool
	/*
	if (!success) {
	throw "IDNotFound";
	}
	*/
}

void IO::extractStartDate(Task &newTask, Value &item) {
	int date = item["startDate"].GetInt();
	bool success = newTask.setStartDate(date);

	if (!success) {
		throw std::runtime_error("StartDateNotFound");
	}
}

void IO::extractStartTime(Task &newTask, Value &item) {
	int time = item["startTime"].GetInt();
	bool success = newTask.setStartTime(time);

	if (!success) {
		throw std::runtime_error("StartTimeNotFound");
	}
}

void IO::extractEndDate(Task &newTask, Value &item) {
	int date = item["endDate"].GetInt();
	bool success = newTask.setEndDate(date);

	if (!success) {
		throw ("EndDateNotFound");
	}
}

void IO::extractEndTime(Task &newTask, Value &item)  {
	int time = item["endTime"].GetInt();
	bool success = newTask.setEndTime(time);

	if (!success) {
		throw std::runtime_error("EndTimeNotFound");
	}
}

//========== Write to File Methods ==========

std::string IO::insertOpenParanthese() {
	return "\t\t{\n";
}

std::string IO::insertCloseParanthese() {
	return "\t\t}\n";
}

std::string IO::writeNameAttribute(Task task) {
	std::string nameString;
	std::string extractedName;

	nameString = "\t\t\t\"name\": ";
	// extractedName = ;
	// Handle inverted commas in case task name contains inverted commas
	// extractedName = Utilities::removeFirstAndLastInvertedCommas(extractedName);
	// extractedName = Utilities::addSlashForInvertedComma(extractedName);
	nameString += retrieveName(task); // extractedName;

	return nameString;
}

std::string IO::writeTypeAttribute(Task task) {
	std::string typeString;

	typeString = "\t\t\t\"type\": ";
	typeString += retrieveType(task);

	return typeString;
}

std::string IO::writeIDAttribute(Task task) {
	std::string IDString;

	IDString = "\t\t\t\"uniqueID\": ";
	IDString += retrieveID(task);

	return IDString;
}

std::string IO::writeLabelAttribute(Task task) {
	std::string labelString;

	labelString = "\t\t\t\"label\": ";
	labelString += retrieveLabel(task);

	return labelString;
}

std::string IO::writeIsDoneAttribute(Task task) {
	std::string isDoneString;

	isDoneString = "\t\t\t\"isDone\": ";
	isDoneString += retrieveIsDone(task);

	return isDoneString;
}

std::string IO::writeIsPriorityAttribute(Task task) {
	std::string isPriorityString;

	isPriorityString = "\t\t\t\"isPriority\": ";
	isPriorityString += retrieveIsPriority(task);

	return isPriorityString;
}

std::string IO::writeStartDateAttribute(Task task) {
	std::string startDateString;

	startDateString = "\t\t\t\"startDate\": ";
	startDateString += retrieveStartDate(task);

	return startDateString;
}

std::string IO::writeStartTimeAttribute(Task task) {
	std::string startTimeString;

	startTimeString = "\t\t\t\"startTime\": ";
	startTimeString += retrieveStartTime(task);

	return startTimeString;
}

std::string IO::writeEndDateAttribute(Task task) {
	std::string EndDateString;

	EndDateString = "\t\t\t\"endDate\": ";
	EndDateString += retrieveEndDate(task);

	return EndDateString;
}

std::string IO::writeEndTimeAttribute(Task task) {
	std::string EndTimeString;

	EndTimeString = "\t\t\t\"endTime\": ";
	EndTimeString += retrieveEndTime(task);

	return EndTimeString;
}

//========== Retrieve Task Attribute Methods ==========

std::string IO::retrieveName(Task task) {
	std::string string;
	string = "\"" + Utilities::addSlashForInvertedComma(task.getName()) + "\",\n";
	return string;
}

std::string IO::retrieveType(Task task) {
	std::string string;
	TaskType type = task.getType();
	string = "\"" + Utilities::taskTypeToString(type) + "\",\n";
	return string;
}

std::string IO::retrieveID(Task task) {
	std::string string;
	int ID = task.getID();
	string = std::to_string(ID) + ",\n";
	return string;
}

std::string IO::retrieveLabel(Task task) {
	std::string string;
	std::vector<std::string> labelVector = task.getLabels();
	string = "[";

	for (unsigned int i = 0; i < labelVector.size(); i++) {
		string += "\"" + labelVector[i] + "\"";
		if (i+1 < labelVector.size()) {
			string += ",\n\t\t\t\t";
		}
	}
	string += "],\n";

	return string;
}

std::string IO::retrieveIsDone(Task task) {
	std::string string;
	bool status = task.getDoneStatus();
	string = Utilities::boolToString(status) + ",\n";
	return string;
}

std::string IO::retrieveIsPriority(Task task) {
	std::string string;
	bool status = task.getPriorityStatus();
	string = Utilities::boolToString(status) + ",\n";
	return string;
}

std::string IO::retrieveStartDate(Task task) {
	std::string string;
	int date = task.getStartDate();
	string = std::to_string(date) + ",\n";
	return string;
}

std::string IO::retrieveStartTime(Task task) {
	std::string string;
	int time = task.getStartTime();
	string = std::to_string(time) + ",\n";
	return string;
}

std::string IO::retrieveEndDate(Task task) {
	std::string string;
	int date = task.getEndDate();
	string = std::to_string(date) + ",\n";
	return string;
}

std::string IO::retrieveEndTime(Task task) {
	std::string string;
	int time = task.getEndTime();
	string = std::to_string(time) + "\n";
	return string;
}

//========== Overloaded Functions ==========

bool IO::fileIsOpen(std::ifstream& inputFile) {
	if (inputFile.is_open())	{
		return true;
	} else {
		return false;
	}
}

bool IO::fileIsOpen(std::ofstream& outputFile) {
	if (outputFile.is_open())	{
		return true;
	} else {
		return false;
	}
}

void IO::initialiseJsonText(std::ofstream& newfile) {
	newfile << "{\n\t\"TaskShark Items\":\n\t[\n";
	return;
}

void IO::closeJsonText(std::ofstream& newfile) {
	newfile << "\t]\n}";
	return;
}

void IO::initialiseRunningCount(std::vector<Task> taskVector) {
	Task lastTask = taskVector.back();
	int lastCount = lastTask.getID();
	lastTask.setRunningCount(lastCount);
	return;
}

```
###### TaskSharkInternal\IO.h
``` h

#ifndef IO_H_
#define IO_H_

#include "Rapidjson\include\rapidjson\document.h"

using namespace rapidjson;

class IO {
private:
	static IO* theOne;
	IO();
	static std::string filePath;
	static const std::string configPath;
	void setLastSavedLocation(std::string fileName);

	bool fileIsOpen(std::ifstream& inputFile);
	bool fileIsOpen(std::ofstream& outputFile);
	Task extractTaskFromJsonObject(Value& item);
	void writeTaskIntoJsonFormat(std::ofstream &newFile, Task task);
	void initialiseRunningCount(std::vector<Task> taskVector);
	void loadWelcomeMessage(std::ifstream& TSconfig);
	void saveWelcomeMessage(std::ofstream& TSconfig);
	void loadCustomCommands(std::ifstream& TSconfig);
	void saveCustomCommands(std::ofstream& TSconfig);
	bool setCommandKeyword(std::string &identifier, std::string keyword);

	void extractName(Task &newTask, Value &item);
	void extractType(Task &newTask, Value &item);
	void extractID(Task &newTask, Value &item);
	void extractLabel(Task &newTask, Value &item);
	void extractDone(Task &newTask, Value &item);
	void extractPriority(Task &newTask, Value &item);
	void extractStartDate(Task &newTask, Value &item);
	void extractStartTime(Task &newTask, Value &item);
	void extractEndDate(Task &newTask, Value &item);
	void extractEndTime(Task &newTask, Value &item);

	void initialiseJsonText(std::ofstream& newfile);
	void closeJsonText(std::ofstream& newfile);
	std::string insertOpenParanthese();
	std::string insertCloseParanthese();
	std::string writeNameAttribute(Task task);
	std::string writeTypeAttribute(Task task);
	std::string writeIDAttribute(Task task);
	std::string writeLabelAttribute(Task task);
	std::string writeIsDoneAttribute(Task task);
	std::string writeIsPriorityAttribute(Task task);
	std::string writeStartDateAttribute(Task task);
	std::string writeStartTimeAttribute(Task task);
	std::string writeEndDateAttribute(Task task);
	std::string writeEndTimeAttribute(Task task);

	std::string retrieveName(Task task);
	std::string retrieveType(Task task);
	std::string retrieveID(Task task);
	std::string retrieveLabel(Task task);
	std::string retrieveIsDone(Task task);
	std::string retrieveIsPriority(Task task);
	std::string retrieveStartDate(Task task);
	std::string retrieveStartTime(Task task);
	std::string retrieveEndDate(Task task);
	std::string retrieveEndTime(Task task);

public:
	static IO* getInstance();
	~IO();
	std::string getFilePath();
	bool setFilePath(std::string newFilePath, std::vector<Task> taskVector, bool isRemovePrevFile=false);
	bool setCustomCommand(std::string identifier, std::string keyword);
	bool saveFile(std::string filePath, std::vector<Task> taskVector);
	std::vector<Task> loadFile(std::string fileName, bool isOverwriteLoadFile=true);

	//========== Getter for Testing ==========
	std::vector<std::string> getText(std::string fileName);
};

#endif
```
###### TaskSharkTests\CommandTest.cpp
``` cpp

#include "stdafx.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

void addThreeSentences(std::vector<Task> copyTask);

namespace TaskSharkTests {
	TEST_CLASS(Command_Add) {
public:
	TEST_METHOD_INITIALIZE(GetInstanceForLogger) {
		TsLogger::getInstance();
	}

	// Originally written by Kiat Boon
	TEST_METHOD(Command_Add_execute) {
		TS::firstLoad = false;
		Task taskOne;
		taskOne.setID(Task::incrementRunningCount());	// Added to fix uniqueID (Aaron)
		taskOne.setName("Sentence one.");
		Add addOne(taskOne);							// Adds taskOne into taskStore (Step 1/2)
		addOne.clearTaskStore();
		addOne.execute();								// Adds taskOne into taskStore (Step 2/2)

		std::vector<Task> copyTask;
		copyTask = addOne.getTaskStore();

		std::vector<Task>::iterator iter;
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence one."), iter->getName());

		Task taskTwo;
		taskTwo.setName("Sentence two.");
		Add addTwo(taskTwo);
		addTwo.execute();

		copyTask = addTwo.getTaskStore();
		iter = copyTask.begin();
		++iter;
		Assert::AreEqual(std::string("Sentence two."),iter->getName());

		Task taskThree;
		taskThree.setName("Sentence three.");
		Add addThree(taskThree);
		addThree.execute();

		copyTask = addThree.getTaskStore();
		iter = copyTask.begin();
		++iter;
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());
	}

	TEST_METHOD(Command_Add_undo) {
		Task taskOne;
		int firstID = Task::incrementRunningCount();
		taskOne.setID(firstID);	// Added to fix uniqueID (Aaron)
		taskOne.setName("Sentence one.");
		Add addOne(taskOne);
		addOne.clearTaskStore();
		addOne.execute();

		std::vector<Task> copyTask;
		copyTask = addOne.getTaskStore();

		std::vector<Task>::iterator iter;
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence one."), iter->getName());

		Task taskTwo;
		taskTwo.setName("Sentence two.");
		int taskTwoID = Task::incrementRunningCount();
		taskTwo.setID(taskTwoID);
		Add addTwo(taskTwo);
		addTwo.execute();

		copyTask = addTwo.getTaskStore();
		iter = copyTask.begin();
		++iter;
		Assert::AreEqual(std::string("Sentence two."),iter->getName());

		Task taskThree;
		taskThree.setName("Sentence three.");
		int taskThreeID = Task::incrementRunningCount();
		taskThree.setID(taskThreeID);
		Add addThree(taskThree);
		addThree.execute();

		copyTask = addThree.getTaskStore();
		iter = copyTask.begin();
		++iter;
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());

		addTwo.undo();

		copyTask = addTwo.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(2,addTwo.getSize());
		Assert::AreEqual(firstID+1,taskTwoID);
		Assert::AreEqual(firstID+2,taskThreeID);
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());

		addOne.undo();

		copyTask = addThree.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(1,addOne.getSize());
		Assert::AreEqual(std::string("Sentence three."),iter->getName());
	}

	TEST_METHOD(Command_Add_Sort) {
		Task taskOne;
		taskOne.setID(Task::incrementRunningCount());	// Added to fix uniqueID (Aaron)
		taskOne.setName("Sentence one.");
		taskOne.setStartDate(150910);
		taskOne.setEndDate(150910);
		taskOne.setPriority();							// Prioritised task
		Add addOne(taskOne);							// Adds taskOne into taskStore (Step 1/2)
		addOne.clearTaskStore();
		addOne.execute();								// Adds taskOne into taskStore (Step 2/2)

		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;

		Task taskTwo;
		taskTwo.setName("Sentence two.");
		taskTwo.setStartDate(151010);
		taskTwo.setEndDate(151010);
		taskTwo.setPriority();							// Prioritised task
		Add addTwo(taskTwo);
		addTwo.execute();

		Task taskThree;
		taskThree.setName("Sentence three.");
		taskThree.setStartDate(150809);
		taskThree.setEndDate(150809);
		Add addThree(taskThree);
		addThree.execute();

		Task taskFour;
		taskFour.setName("Sentence four.");
		taskFour.setStartDate(150910);
		taskFour.setEndDate(150910);
		Add addFour(taskFour);
		addFour.execute();

		copyTask = addFour.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(150809, iter->getStartDate());	
		++iter;
		Assert::AreEqual(150910, iter->getStartDate());	
		++iter;
		Assert::AreEqual(150910,iter->getStartDate());
		++iter;
		Assert::AreEqual(151010, iter->getStartDate());
	}
	};

	TEST_CLASS(Command_Delete) {
public:
	TEST_METHOD(Command_Delete_Execute) {
		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;
		addThreeSentences(copyTask);

		Delete deleteTwo(2);
		deleteTwo.execute();

		copyTask = deleteTwo.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(2,deleteTwo.getSize());
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());

		Delete deleteOne(1);
		deleteOne.execute();

		copyTask = deleteOne.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(1,deleteOne.getSize());
		Assert::AreEqual(std::string("Sentence three."),iter->getName());
	}

	TEST_METHOD(Command_Delete_Undo) {
		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;
		addThreeSentences(copyTask);

		Delete deleteTwo(2);
		deleteTwo.execute();

		copyTask = deleteTwo.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(2,deleteTwo.getSize());
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());

		Delete deleteOne(1);
		deleteOne.execute();

		copyTask = deleteOne.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(1,deleteOne.getSize());
		Assert::AreEqual(std::string("Sentence three."),iter->getName());

		deleteOne.undo();

		copyTask = deleteOne.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(2,deleteOne.getSize());
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());

		deleteTwo.undo();

		copyTask = deleteOne.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(3,deleteTwo.getSize());
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence two."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());
	}
	};

	TEST_CLASS(Command_Modify) {
public:
	TEST_METHOD(Command_Modify_execute_FLOATtoTODO) {
		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;
		addThreeSentences(copyTask);

		View viewAll(VIEWTYPE_ALL, "");
		viewAll.execute();

		std::vector<FieldType> fields;
		fields.push_back(NAME);
		Task modifiedTask;
		modifiedTask.setName("New Sentence Two");
		Modify modifyTwo(2, fields, modifiedTask);

		modifyTwo.execute();

		copyTask = modifyTwo.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("New Sentence Two"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());
		int IDthree = iter->getID();

		fields.push_back(TODO_DATE);
		Assert::AreEqual((size_t)2,fields.size());
		modifiedTask.setName("New Sentence Three");
		modifiedTask.setEndDate(150101);
		modifiedTask.setStartDate(150101);
		Modify modifyThree(3, fields, modifiedTask);

		modifyThree.execute();

		copyTask = modifyThree.getTaskStore();
		iter = copyTask.begin();
		if (TODO != iter->getType()) assert (false);
		Assert::AreEqual(IDthree,iter->getID());
		Assert::AreEqual(150101,iter->getEndDate());
		Assert::AreEqual(150101,iter->getStartDate());
		Assert::AreEqual(TIME_NOT_SET,iter->getStartTime());		
		Assert::AreEqual(std::string("New Sentence Three"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("New Sentence Two"),iter->getName());
	}

	TEST_METHOD(Command_Modify_execute_FLOATtoEVENT) {
		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;
		addThreeSentences(copyTask);

		std::vector<FieldType> fields;
		fields.push_back(NAME);
		Task modifiedTask;
		modifiedTask.setName("New Sentence Three");
		fields.push_back(END_DATE);
		fields.push_back(START_DATE);
		modifiedTask.setStartDate(150101);	
		modifiedTask.setEndDate(150201);
		Assert::AreEqual((size_t)3,fields.size());
		Modify modifyThree(3, fields, modifiedTask);

		copyTask = modifyThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence two."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());
		int IDthree = iter->getID();

		modifyThree.execute();

		copyTask = modifyThree.getTaskStore();
		iter = copyTask.begin();
		if (EVENT != iter->getType()) assert (false);
		Assert::AreEqual(IDthree,iter->getID());
		Assert::AreEqual(150101,iter->getStartDate());
		Assert::AreEqual(150201,iter->getEndDate());
		Assert::AreEqual(TIME_NOT_SET,iter->getStartTime());
		Assert::AreEqual(std::string("New Sentence Three"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence two."),iter->getName());
	}

	TEST_METHOD(Command_Modify_undo) {
		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;
		addThreeSentences(copyTask);

		std::vector<FieldType> fields;
		fields.push_back(NAME);
		Task modifiedTask;
		modifiedTask.setName("New Sentence Two");
		Modify modifyTwo(2, fields, modifiedTask);

		modifyTwo.execute();

		copyTask = modifyTwo.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("New Sentence Two"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());

		fields.push_back(TODO_DATE);
		modifiedTask.setName("New Sentence Three");
		modifiedTask.setStartDate(150101);
		modifiedTask.setEndDate(150101);
		Modify modifyThree(3, fields, modifiedTask);

		modifyThree.execute();

		copyTask = modifyThree.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("New Sentence Three"),iter->getName());
		Assert::AreEqual(150101,iter->getEndDate());
		++iter;
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("New Sentence Two"),iter->getName());		

		modifyThree.undo();

		copyTask = modifyThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence three."),iter->getName());
		Assert::AreEqual(0,iter->getStartDate());
		Assert::AreEqual(0,iter->getEndDate());
		++iter;
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(0,iter->getStartDate());
		Assert::AreEqual(0,iter->getEndDate());
		Assert::AreEqual(std::string("New Sentence Two"),iter->getName());

		modifyTwo.undo();

		copyTask = modifyTwo.getTaskStore();
		iter = copyTask.begin();
		++iter;
		++iter;
		Assert::AreEqual(std::string("Sentence two."),iter->getName());
	}

	TEST_METHOD(Command_Modify_undo_changeview) {
		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;
		addThreeSentences(copyTask);

		std::vector<FieldType> fields;
		fields.push_back(NAME);
		Task modifiedTask;
		modifiedTask.setName("New Sentence Two");
		Modify modifyTwo(2, fields, modifiedTask);

		modifyTwo.execute();

		copyTask = modifyTwo.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("New Sentence Two"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence three."),iter->getName());

		fields.push_back(TODO_DATE);
		modifiedTask.setName("New Sentence Three");
		modifiedTask.setStartDate(150101);
		modifiedTask.setEndDate(150101);
		Modify modifyThree(3, fields, modifiedTask);

		modifyThree.execute();

		copyTask = modifyThree.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("New Sentence Three"),iter->getName());
		Assert::AreEqual(150101,iter->getEndDate());
		++iter;
		Assert::AreEqual(std::string("Sentence one."),iter->getName());
		++iter;
		Assert::AreEqual(std::string("New Sentence Two"),iter->getName());		
		
		View viewTodo(VIEWTYPE_TODO, "");
		viewTodo.execute();

		modifyThree.undo();

		copyTask = modifyThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)1,copyTask.size());
		Assert::AreEqual(std::string("Sentence three."),iter->getName());
		Assert::AreEqual(0,iter->getStartDate());
		Assert::AreEqual(0,iter->getEndDate());
		
		modifyTwo.undo();

		copyTask = modifyTwo.getTaskStore();
		iter = copyTask.begin();
		++iter;
		++iter;
		Assert::AreEqual(std::string("Sentence two."),iter->getName());
	}
	};

	TEST_CLASS(Command_Search) {
public:
	TEST_METHOD(Command_Search_execute) {
		// Add tasks
		Task task;
		task.setID(Task::incrementRunningCount());
		task.setName("one two three");
		Add addOne(task);
		addOne.clearTaskStore();
		addOne.execute();

		task.setID(Task::incrementRunningCount());
		task.setName("one three five");
		Add addTwo(task);
		addTwo.execute();

		task.setID(Task::incrementRunningCount());
		task.setName("one five seven");
		Add addThree(task);
		addThree.execute();

		std::vector<Task> copyTask;
		copyTask = addThree.getTaskStore();

		// Start searching
		Search searchOne("one");
		searchOne.execute();

		copyTask = addThree.getCurrentView();
		std::vector<Task>::iterator iter;
		iter = copyTask.begin();
		Assert::AreEqual((size_t)3,copyTask.size());
		Assert::AreEqual(std::string("one two three"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one three five"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one five seven"),iter->getName());

		Search searchThree("three");
		searchThree.execute();

		copyTask = searchThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)2,copyTask.size());
		Assert::AreEqual(std::string("one two three"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one three five"),iter->getName());

		Search searchFive("fiVe");
		searchFive.execute();

		copyTask = addThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)2,copyTask.size());
		Assert::AreEqual(std::string("one three five"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one five seven"),iter->getName());

		Search searchSeven("sEveN");
		searchSeven.execute();

		copyTask = addThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)1,copyTask.size());
		Assert::AreEqual(std::string("one five seven"),iter->getName());

		Search searchGibberish("51267");
		searchGibberish.execute();

		copyTask = addThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)0,copyTask.size());
	}

	TEST_METHOD(Command_Search_undo) {
		// Add tasks
		Task task;
		task.setID(Task::incrementRunningCount());
		task.setName("one two three");
		Add addOne(task);
		addOne.clearTaskStore();
		addOne.execute();

		task.setID(Task::incrementRunningCount());
		task.setName("one three five");
		Add addTwo(task);
		addTwo.execute();

		task.setID(Task::incrementRunningCount());
		task.setName("one five seven");
		Add addThree(task);
		addThree.execute();

		std::vector<Task> copyTask;
		copyTask = addThree.getTaskStore();

		// Start searching
		Search searchOne("one");
		searchOne.execute();

		copyTask = addThree.getCurrentView();
		std::vector<Task>::iterator iter;
		iter = copyTask.begin();
		Assert::AreEqual((size_t)3,copyTask.size());
		Assert::AreEqual(std::string("one two three"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one three five"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one five seven"),iter->getName());

		Search searchThree("three");
		searchThree.execute();

		copyTask = searchThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)2,copyTask.size());
		Assert::AreEqual(std::string("one two three"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one three five"),iter->getName());

		searchThree.undo();

		copyTask = addThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)3,copyTask.size());
		Assert::AreEqual(std::string("one two three"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one three five"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one five seven"),iter->getName());

		Search searchFive("fiVe");
		searchFive.execute();

		copyTask = addThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)2,copyTask.size());
		Assert::AreEqual(std::string("one three five"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one five seven"),iter->getName());

		Search searchSeven("sEveN");
		searchSeven.execute();

		copyTask = addThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)1,copyTask.size());
		Assert::AreEqual(std::string("one five seven"),iter->getName());

		searchSeven.undo();

		copyTask = addThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)2,copyTask.size());
		Assert::AreEqual(std::string("one three five"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one five seven"),iter->getName());

		searchFive.undo();

		copyTask = addThree.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)3,copyTask.size());
		Assert::AreEqual(std::string("one two three"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one three five"),iter->getName());
		++iter;
		Assert::AreEqual(std::string("one five seven"),iter->getName());
	}
	};

	TEST_CLASS(Command_MarkDone) {
public:
	TEST_METHOD(Command_MarkDone_execute) {
		// Add tasks
		Task task;
		Add addOne(task);
		addOne.clearTaskStore();
		addOne.execute();

		task.setID(task.incrementRunningCount());
		task.markDone();
		Add addTwo(task);
		addTwo.execute();

		// KB: to include done tasks
		View viewAll(VIEWTYPE_ALL, "");
		viewAll.execute();

		// Start markDone
		Markdone markdoneOne(1);	
		markdoneOne.execute();		

		std::vector<Task> copyTask;
		copyTask = addTwo.getCurrentView();
		std::vector<Task>::iterator iter;
		iter = copyTask.begin();
		Assert::AreEqual((size_t)0,copyTask.size());
		copyTask = addTwo.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(true,iter->getDoneStatus());

		View viewPast(VIEWTYPE_PAST, "");
		viewPast.execute();

		Markdone markdoneTwo(1);
		markdoneTwo.execute();

		copyTask = addTwo.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)0,copyTask.size());		
	}

	TEST_METHOD(Command_MarkDone_undo) {
		// Add tasks
		Task task;
		Add addOne(task);
		addOne.clearTaskStore();
		addOne.execute();

		task.setID(task.incrementRunningCount());
		task.markDone();
		Add addTwo(task);
		addTwo.execute();

		View viewAll(VIEWTYPE_ALL, "");
		viewAll.execute();

		// Start markDone
		Markdone markdoneOne(1);
		markdoneOne.execute();

		std::vector<Task> copyTask;
		copyTask = addTwo.getCurrentView();
		std::vector<Task>::iterator iter;
		iter = copyTask.begin();
		Assert::AreEqual((size_t)0,copyTask.size());
		copyTask = addTwo.getTaskStore();
		iter = copyTask.begin();
		Assert::AreEqual(true,iter->getDoneStatus());

		View viewPast(VIEWTYPE_PAST, "");
		viewPast.execute();

		Markdone markdoneTwo(1);
		markdoneTwo.execute();

		copyTask = addTwo.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)0,copyTask.size()); // Goes back to deafult view

		markdoneTwo.undo();

		copyTask = addTwo.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)0,copyTask.size());
		copyTask = addTwo.getTaskStore();
		iter = copyTask.begin();
		++iter;
		Assert::AreEqual(true,iter->getDoneStatus());

		markdoneOne.undo();

		copyTask = addTwo.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)1,copyTask.size());
		Assert::AreEqual(false,iter->getDoneStatus());
	}
	};

	TEST_CLASS(Command_UnmarkDone) {
public:
	TEST_METHOD(Command_UnmarkDone_execute) {
		// Add tasks
		Task task;
		Add addOne(task);
		addOne.clearTaskStore();
		addOne.execute();

		task.setID(task.incrementRunningCount());
		task.markDone();
		Add addTwo(task);
		addTwo.execute();

		View viewAll(VIEWTYPE_ALL, "");
		viewAll.execute();

		// Start unmarkDone
		UnmarkDone unmarkdoneOne(1);
		unmarkdoneOne.execute();

		std::vector<Task> copyTask;
		copyTask = addTwo.getCurrentView();
		std::vector<Task>::iterator iter;
		iter = copyTask.begin();
		Assert::AreEqual((size_t)1,copyTask.size());

		View viewPast(VIEWTYPE_PAST, "");
		viewPast.execute();

		UnmarkDone unmarkdoneTwo(1);
		unmarkdoneTwo.execute();

		copyTask = addTwo.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)2,copyTask.size());
		++iter;
		Assert::AreEqual(false,iter->getDoneStatus());
	}

	TEST_METHOD(Command_UnmarkDone_undo) {
		// Add tasks
		Task task;
		Add addOne(task);
		addOne.clearTaskStore();
		addOne.execute();

		task.setID(task.incrementRunningCount());
		task.markDone();
		Add addTwo(task);
		addTwo.execute();

		View viewAll(VIEWTYPE_ALL, "");
		viewAll.execute();

		// Start unmarkDone
		UnmarkDone unmarkdoneOne(1);
		unmarkdoneOne.execute();

		std::vector<Task> copyTask;
		copyTask = addTwo.getCurrentView();
		std::vector<Task>::iterator iter;
		iter = copyTask.begin();
		Assert::AreEqual((size_t)1,copyTask.size());

		View viewPast(VIEWTYPE_PAST, "");
		viewPast.execute();

		UnmarkDone unmarkdoneTwo(1);
		unmarkdoneTwo.execute();

		copyTask = addTwo.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)2,copyTask.size());
		copyTask = addTwo.getTaskStore();
		iter = copyTask.begin();
		++iter;
		Assert::AreEqual(false,iter->getDoneStatus());

		unmarkdoneTwo.undo();

		copyTask = addTwo.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)1,copyTask.size());
		copyTask = addTwo.getTaskStore();
		iter = copyTask.begin();
		++iter;
		Assert::AreEqual(true,iter->getDoneStatus());

		unmarkdoneOne.undo();

		copyTask = addTwo.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual((size_t)1,copyTask.size());
	}
	};

	TEST_CLASS(Command_View) {
public:

	TEST_METHOD(Command_View_TaskType) {
		// TODO: Implement for other task types too
		Task taskOne;
		taskOne.setID(Task::incrementRunningCount());	// Added to fix uniqueID (Aaron)
		taskOne.setName("Sentence one.");
		taskOne.setType(FLOATING);
		taskOne.setStartDate(150910);
		taskOne.setEndDate(150910);
		Add addOne(taskOne);							// Adds taskOne into taskStore (Step 1/2)
		addOne.clearTaskStore();
		addOne.execute();								// Adds taskOne into taskStore (Step 2/2)

		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;

		Task taskTwo;
		taskTwo.setName("Sentence two.");
		taskTwo.setType(TODO);
		taskTwo.setStartDate(151010);
		taskTwo.setEndDate(151010);
		Add addTwo(taskTwo);
		addTwo.execute();

		Task taskThree;
		taskThree.setName("Sentence three.");
		taskThree.setType(TODO);
		taskThree.setStartDate(150809);
		taskThree.setEndDate(150809);
		Add addThree(taskThree);
		addThree.execute();

		Task taskFour;
		taskFour.setName("Sentence four.");
		taskFour.setType(FLOATING);
		taskFour.setStartDate(150910);
		taskFour.setEndDate(150910);
		Add addFour(taskFour);
		addFour.execute();

		View viewFloating(VIEWTYPE_FLOATING, "");
		viewFloating.execute();

		copyTask = viewFloating.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence one."), iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence four."), iter->getName());
	}

	TEST_METHOD(Command_View_All) {
		// Three: 150809
		// One: 150910
		// Four: 150910	
		// Two: 151010
		// View all only views done tasks

		Task taskOne;
		taskOne.setID(Task::incrementRunningCount());	// Added to fix uniqueID (Aaron)
		taskOne.setName("Sentence one.");
		taskOne.setStartDate(150910);
		taskOne.setEndDate(150910);
		Add addOne(taskOne);							// Adds taskOne into taskStore (Step 1/2)
		addOne.clearTaskStore();
		addOne.execute();								// Adds taskOne into taskStore (Step 2/2)

		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;

		Task taskTwo;
		taskTwo.setName("Sentence two.");
		taskTwo.setStartDate(151010);
		taskTwo.setEndDate(151010);
		Add addTwo(taskTwo);
		addTwo.execute();

		Task taskThree;
		taskThree.setName("Sentence three.");
		taskThree.setStartDate(150809);
		taskThree.setEndDate(150809);
		taskThree.markDone();
		Add addThree(taskThree);
		addThree.execute();

		Task taskFour;
		taskFour.setName("Sentence four.");
		taskFour.setStartDate(150910);
		taskFour.setEndDate(150910);
		Add addFour(taskFour);
		addFour.execute();

		View viewAll(VIEWTYPE_ALL, "");
		viewAll.execute();

		copyTask = viewAll.getCurrentView();
		iter = copyTask.begin();
		// Assert::AreEqual(std::string("Sentence three."), iter->getName());
		//++iter;
		Assert::AreEqual(std::string("Sentence one."), iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence four."), iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence two."), iter->getName());
		// Assert::AreEqual(150809, iter->getStartDate());	
	}

	TEST_METHOD(Command_View_Done) {
		Task taskOne;
		taskOne.setID(Task::incrementRunningCount());	// Added to fix uniqueID (Aaron)
		taskOne.setName("Sentence one.");
		taskOne.setStartDate(150910);
		taskOne.setEndDate(150910);
		Add addOne(taskOne);							// Adds taskOne into taskStore (Step 1/2)
		addOne.clearTaskStore();
		addOne.execute();								// Adds taskOne into taskStore (Step 2/2)

		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;

		Task taskTwo;
		taskTwo.setName("Sentence two.");
		taskTwo.setStartDate(151010);
		taskTwo.setEndDate(151010);
		Add addTwo(taskTwo);
		addTwo.execute();

		Task taskThree;
		taskThree.setName("Sentence three.");
		taskThree.setStartDate(150809);
		taskThree.setEndDate(150809);
		taskThree.markDone();
		Add addThree(taskThree);
		addThree.execute();

		Task taskFour;
		taskFour.setName("Sentence four.");
		taskFour.setStartDate(150910);
		taskFour.setEndDate(150910);
		Add addFour(taskFour);
		addFour.execute();

		View viewPast(VIEWTYPE_PAST, "");
		viewPast.execute();

		copyTask = viewPast.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence three."), iter->getName());		
	}

	TEST_METHOD(Command_View_Notdone) {
		Task taskOne;
		taskOne.setID(Task::incrementRunningCount());	// Added to fix uniqueID (Aaron)
		taskOne.setName("Sentence one.");
		taskOne.setStartDate(150910);
		taskOne.setEndDate(150910);
		Add addOne(taskOne);							// Adds taskOne into taskStore (Step 1/2)
		addOne.clearTaskStore();
		addOne.execute();								// Adds taskOne into taskStore (Step 2/2)

		std::vector<Task> copyTask;
		std::vector<Task>::iterator iter;

		Task taskTwo;
		taskTwo.setName("Sentence two.");
		taskTwo.setStartDate(151010);
		taskTwo.setEndDate(151010);
		Add addTwo(taskTwo);
		addTwo.execute();

		Task taskThree;
		taskThree.setName("Sentence three.");
		taskThree.setStartDate(150809);
		taskThree.setEndDate(150809);
		taskThree.markDone();
		Add addThree(taskThree);
		addThree.execute();

		Task taskFour;
		taskFour.setName("Sentence four.");
		taskFour.setStartDate(150910);
		taskFour.setEndDate(150910);
		Add addFour(taskFour);
		addFour.execute();

		/*
		View viewNotDone(VIEWTYPE_NOTDONE, "");
		viewNotDone.execute();

		copyTask = viewNotDone.getCurrentView();
		iter = copyTask.begin();
		Assert::AreEqual(std::string("Sentence one."), iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence four."), iter->getName());
		++iter;
		Assert::AreEqual(std::string("Sentence two."), iter->getName());
		*/
	}
	};

	TEST_CLASS(Command_Load) {
public:
	TEST_METHOD(Command_Load_Execute_empty) {
		try {
			IO* io = IO::getInstance();
			Load load(io->getFilePath());
			load.execute();
		} catch (std::exception e) {
			Assert::AreEqual("File does not exist",e.what());
		}
	}
	};

	TEST_CLASS(Command_Pick) {
public:
	Command* cmd;
	Command* viewAllCmd;
	Parser* parser;
	History* history;
	Task task;
	std::string userInput;

	TEST_METHOD_INITIALIZE(ClearTaskStoreAndGetParser) {
		cmd->clearTaskStore();
		parser = Parser::getInstance();
		history = History::getInstance();
		history->clearHistory();
		TS::firstLoad = false;
	}

	TEST_METHOD(Command_Pick_reserve_empty) {
		userInput = "add Recursion Lecture on 1 dec by 2 pm";
		cmd = parser->parse(userInput);
		cmd->execute();
		userInput = "view all";
		viewAllCmd = parser->parse(userInput);
		viewAllCmd->execute();
		task = cmd->getTaskStore().back();
		Assert::AreEqual(std::string("Recursion Lecture"),task.getName());
		Assert::AreEqual(std::string("TODO"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151201, task.getStartDate());
		Assert::AreEqual(1400, task.getStartTime());
		Assert::AreEqual(151201, task.getEndDate());
		Assert::AreEqual(1400, task.getEndTime());



		userInput = "pick 1 reserve";
		cmd = parser->parse(userInput);
		cmd->execute();
		task = cmd->getTaskStore().back();
		Assert::AreEqual(std::string("Recursion Lecture"),task.getName());
		Assert::AreEqual(std::string("TODO"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151201, task.getStartDate());
		Assert::AreEqual(1400, task.getStartTime());
		Assert::AreEqual(151201, task.getEndDate());
		Assert::AreEqual(1400, task.getEndTime());
	}

	TEST_METHOD(Command_Pick_reserve_TODOtoEVENT) {
		userInput = "add Recursion Lecture on 1 dec by 2 pm reserve on 3 dec from 4 pm to 5 pm";
		cmd = parser->parse(userInput);
		cmd->execute();
		userInput = "view all";
		viewAllCmd = parser->parse(userInput);
		viewAllCmd->execute();
		task = cmd->getTaskStore().back();
		Assert::AreEqual(std::string("Recursion Lecture"),task.getName());
		Assert::AreEqual(std::string("TODO"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151201, task.getStartDate());
		Assert::AreEqual(1400, task.getStartTime());
		Assert::AreEqual(151201, task.getEndDate());
		Assert::AreEqual(1400, task.getEndTime());

		history->add(cmd);
		Assert::AreEqual(1,history->getUndoSize());

		userInput = "pick 1 reserve"; // 'r' and 're' are alternatives to 'reserve'
		cmd = parser->parse(userInput);
		cmd->execute();
		task = cmd->getTaskStore().back();
		Assert::AreEqual(std::string("Recursion Lecture"),task.getName());
		Assert::AreEqual(std::string("EVENT"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151203, task.getStartDate());
		Assert::AreEqual(1600, task.getStartTime());
		Assert::AreEqual(151203, task.getEndDate());
		Assert::AreEqual(1700, task.getEndTime());

		history->add(cmd);
		Assert::AreEqual(2,history->getUndoSize());
	}

	TEST_METHOD(Command_Pick_reserve_Undo) {
		Command_Pick_reserve_TODOtoEVENT();

		userInput = "undo";
		cmd = parser->parse(userInput);
		cmd->execute();
		task = cmd->getTaskStore().back();
		Assert::AreEqual(std::string("Recursion Lecture"),task.getName());
		Assert::AreEqual(std::string("TODO"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151201, task.getStartDate());
		Assert::AreEqual(1400, task.getStartTime());
		Assert::AreEqual(151201, task.getEndDate());
		Assert::AreEqual(1400, task.getEndTime());
		TS::firstLoad = true;
	}
	};
}

void addThreeSentences(std::vector<Task> copyTask) {
	Task taskOne;
	taskOne.setID(Task::incrementRunningCount());
	taskOne.setName("Sentence one.");
	Add addOne(taskOne);
	addOne.clearTaskStore();
	addOne.execute();

	copyTask = addOne.getTaskStore();

	std::vector<Task>::iterator iter;
	iter = copyTask.begin();
	Assert::AreEqual(std::string("Sentence one."), iter->getName());

	Task taskTwo;
	taskTwo.setName("Sentence two.");
	taskTwo.setID(Task::incrementRunningCount());
	Add addTwo(taskTwo);
	addTwo.execute();

	copyTask = addTwo.getTaskStore();
	iter = copyTask.begin();
	++iter;
	Assert::AreEqual(std::string("Sentence two."),iter->getName());

	Task taskThree;
	taskThree.setName("Sentence three.");
	taskThree.setID(Task::incrementRunningCount());
	Add addThree(taskThree);
	addThree.execute();

	copyTask = addThree.getTaskStore();
	iter = copyTask.begin();
	++iter;
	++iter;
	Assert::AreEqual(std::string("Sentence three."),iter->getName());
}
```
###### TaskSharkTests\IOTest.cpp
``` cpp

#include "stdafx.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace TaskSharkTests {
	TEST_CLASS(LoadFileTest) {
public:
	IO* io;
	std::vector<Task> emptyVector;
	std::vector<Task> actualVector;

	TEST_METHOD_INITIALIZE(GetInstanceIO) {
		io = IO::getInstance();
	}

	TEST_METHOD(IO_loadFile_emptyFile) {
		// Empty file should load empty vector
		io->saveFile("TEXT.txt", emptyVector);

		actualVector = io->loadFile("TEXT.txt");
		Assert::AreEqual(emptyVector.size(), actualVector.size());
	}

	TEST_METHOD(IO_loadFile_fileDoesntExist) {
		// Non-existent file should load empty vector
		try {
			actualVector = io->loadFile(""); // Exception thrown if file does not exist
		} catch (std::exception e) {
			Assert::AreEqual("File does not exist",e.what());
			Assert::AreEqual(emptyVector.size(),actualVector.size());
		}
	}

	TEST_METHOD(IO_loadFile_loadGibberish) {
		// Gibberish file name should load empty vector
		try {
			actualVector = io->loadFile("~`!@#$%^&*()_-+="); // Exception thrown if file does not exist
		} catch (std::exception e) {
			Assert::AreEqual("File does not exist",e.what());
			Assert::AreEqual(emptyVector.size(),actualVector.size());
		}
	}

	TEST_METHOD(IO_loadFile_oneTask) {
		std::vector<Task> textVector;
		Task newTask;
		textVector.push_back(newTask);
		io->saveFile("TEXT.txt", textVector);

		actualVector = io->loadFile("TEXT.txt");
		Assert::AreEqual(textVector.size(), actualVector.size());

		for (unsigned int i = 0; i < actualVector.size(); i++) {
			Task task1 = textVector[i];
			Task task2 = actualVector[i];

			Assert::AreEqual(task1.getDoneStatus() , task2.getDoneStatus());
			Assert::AreEqual(task1.getEndDate() , task2.getEndDate());
			Assert::AreEqual(task1.getEndTime() , task2.getEndTime());
			Assert::AreEqual(task1.getID() , task2.getID());
			Assert::AreEqual(task1.getLabelString() , task2.getLabelString());
			Assert::AreEqual(task1.getName() , task2.getName());
			Assert::AreEqual(task1.getPriorityStatus() , task2.getPriorityStatus());
			Assert::AreEqual(task1.getStartDate() , task2.getStartDate());
			Assert::AreEqual(task1.getStartTime() , task2.getStartTime());
			Assert::AreEqual(Utilities::taskTypeToString(task1.getType()) , Utilities::taskTypeToString(task2.getType()));
			/*
			// Assert::AreEqual cannot compare vectors and Tasks
			if (!Task::tasksAreEqual(textVector[i], actualVector[i])) {
			Assert::Fail();
			// Assert::AreEqual(textVector[i], actualVector[i]);
			}
			*/
		}
	}

	TEST_METHOD(IO_loadFile_threeTasks) {
		std::vector<Task> textVector;
		Task newTask;
		textVector.push_back(newTask);
		textVector.push_back(newTask);
		textVector.push_back(newTask);
		io->saveFile("TEXT.txt", textVector);

		std::vector<Task> actualVector = io->loadFile("TEXT.txt");
		Assert::AreEqual(textVector.size(), actualVector.size());

		for (unsigned int i = 0; i < actualVector.size(); i++) {
			Task task1 = textVector[i];
			Task task2 = actualVector[i];

			Assert::AreEqual(task1.getDoneStatus() , task2.getDoneStatus());
			Assert::AreEqual(task1.getEndDate() , task2.getEndDate());
			Assert::AreEqual(task1.getEndTime() , task2.getEndTime());
			Assert::AreEqual(task1.getID() , task2.getID());
			Assert::AreEqual(task1.getLabelString() , task2.getLabelString());
			Assert::AreEqual(task1.getName() , task2.getName());
			Assert::AreEqual(task1.getPriorityStatus() , task2.getPriorityStatus());
			Assert::AreEqual(task1.getStartDate() , task2.getStartDate());
			Assert::AreEqual(task1.getStartTime() , task2.getStartTime());
			Assert::AreEqual(Utilities::taskTypeToString(task1.getType()) , Utilities::taskTypeToString(task2.getType()));
			/*
			// Assert::AreEqual cannot compare vectors and Tasks
			if (!Task::tasksAreEqual(textVector[i], actualVector[i])) {
			Assert::Fail();
			// Assert::AreEqual(textVector[i], actualVector[i]);
			}
			*/
		}
	}

	// Use only if incorrect input
	// TEST_METHOD(IO_loadFile_correctStringReadIn)	{
	/*
	// Test if what is read to rapidJSON is the correct file contents
	std::ifstream inputFile("JSONTEXT.txt");
	std::string hardstring = "\"TaskShark Items\":\n[\n]";
	std::string inputFileText((std::istreambuf_iterator<char>(inputFile)),

	std::istreambuf_iterator<char>());
	Assert::AreEqual(hardstring, inputFileText);
	}
	*/
	};

	//========== SaveFileTest ==========
	TEST_CLASS(SaveFileTest) {
public:
	IO* io;
	TEST_METHOD_INITIALIZE(GetInstanceForIO) {
		io = IO::getInstance();
	}

	TEST_METHOD(IO_saveFile_fileDoesntExist) {
		// Cannot open file to save
		std::vector<Task> emptyVector;
		bool success = io->saveFile("", emptyVector);

		Assert::AreEqual(false, success);
	}

	TEST_METHOD(IO_saveFile_oneLine) {
		std::vector<Task> textVector;
		Task newTask;
		textVector.push_back(newTask);

		bool success = io->saveFile("TEXT.txt", textVector);
		Assert::AreEqual(true,success);
		std::vector<std::string> actualText = io->getText("TEXT.txt");

		std::string expectedText[] = {
			"{",
			"\t\"TaskShark Items\":",
			"\t[",
			"\t\t{",
			"\t\t\t\"name\": \"\",",
			"\t\t\t\"type\": \"FLOATING\",",
			"\t\t\t\"uniqueID\": 0,",
			"\t\t\t\"label\": [],",
			"\t\t\t\"isDone\": false,",
			"\t\t\t\"isPriority\": false,",
			// "\t\t\t\"startDay\": \"SUN\",",
			"\t\t\t\"startDate\": 0,",
			"\t\t\t\"startTime\": -1,",
			// "\t\t\t\"endDay\": \"SUN\",",
			"\t\t\t\"endDate\": 0,",
			"\t\t\t\"endTime\": -1",
			"\t\t}",
			"\t]",
			"}"
		};

		// TODO: Assert::AreEqual for diff vector sizes
		Assert::AreEqual((size_t) 17, actualText.size());

		for (unsigned int i = 0; i < actualText.size(); i++) {
			Assert::AreEqual(expectedText[i], actualText[i]);
		}
	}

	TEST_METHOD(IO_saveFile_threeLines) {
		std::vector<Task> textVector;
		Task newTask;
		newTask.setID(Task::incrementRunningCount()); // Added to fix uniqueID (Aaron)
		textVector.push_back(newTask);
		textVector.push_back(newTask);
		textVector.push_back(newTask);

		bool success = io->saveFile("TEXT.txt", textVector);
		Assert::AreEqual(true,success);
		std::vector<std::string> actualText = io->getText("TEXT.txt");

		std::string expectedText[] = {
			"{",
			"\t\"TaskShark Items\":",
			"\t[",
			"\t\t{",
			"\t\t\t\"name\": \"\",",
			"\t\t\t\"type\": \"FLOATING\",",
			"\t\t\t\"uniqueID\": 1,",
			"\t\t\t\"label\": [],",
			"\t\t\t\"isDone\": false,",
			"\t\t\t\"isPriority\": false,",
			// "\t\t\t\"startDay\": \"SUN\",",
			"\t\t\t\"startDate\": 0,",
			"\t\t\t\"startTime\": -1,",
			// "\t\t\t\"endDay\": \"SUN\",",
			"\t\t\t\"endDate\": 0,",
			"\t\t\t\"endTime\": -1",
			"\t\t}",
			"\t\t,",
			"\t\t{",
			"\t\t\t\"name\": \"\",",
			"\t\t\t\"type\": \"FLOATING\",",
			"\t\t\t\"uniqueID\": 1,",
			"\t\t\t\"label\": [],",
			"\t\t\t\"isDone\": false,",
			"\t\t\t\"isPriority\": false,",
			// "\t\t\t\"startDay\": \"SUN\",",
			"\t\t\t\"startDate\": 0,",
			"\t\t\t\"startTime\": -1,",
			//"\t\t\t\"endDay\": \"SUN\",",
			"\t\t\t\"endDate\": 0,",
			"\t\t\t\"endTime\": -1",
			"\t\t}",
			"\t\t,",
			"\t\t{",
			"\t\t\t\"name\": \"\",",
			"\t\t\t\"type\": \"FLOATING\",",
			"\t\t\t\"uniqueID\": 1,",
			"\t\t\t\"label\": [],",
			"\t\t\t\"isDone\": false,",
			"\t\t\t\"isPriority\": false,",
			// "\t\t\t\"startDay\": \"SUN\",",
			"\t\t\t\"startDate\": 0,",
			"\t\t\t\"startTime\": -1,",
			// "\t\t\t\"endDay\": \"SUN\",",
			"\t\t\t\"endDate\": 0,",
			"\t\t\t\"endTime\": -1",
			"\t\t}",
			"\t]",
			"}"
		};

		for (unsigned int i = 0; i < actualText.size(); i++) {
			Assert::AreEqual(expectedText[i], actualText[i]);
		}
	}

	// TEST_METHOD(IO_saveFile_noText) {
	/*
	io = IO::getInstance();
	std::vector<Task> emptyVector;
	std::string expectedText[] = {"{","\t\"TaskShark Items\":", "\t[","\t]","}"};

	bool success = io->saveFile("TEXT.txt", emptyVector);

	std::vector<std::string> actualText = io->getText("TEXT.txt");

	// std::vector<std::string> actualTextVector = io->getText("TEXT.txt");
	// std::string actualText = Utilities::vecToString(actualTextVector);

	for (unsigned int i = 0; i < actualText.size(); i++) {
	Assert::AreEqual(expectedText[i], actualText[i]);
	}
	}
	*/
	};

```
