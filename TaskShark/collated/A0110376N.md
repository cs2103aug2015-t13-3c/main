# A0110376N
###### TaskSharkInternal\Command.cpp
``` cpp

//==================================================
//                       PICK
//==================================================

//============= PICK : PUBLIC METHODS ============

Pick::Pick(int taskID, bool isPick) : Modify(PICK) {
	isFreePeriodMode = false;
	modifyID = taskID;
	pickReserve = isPick;
}

Pick::~Pick() {}

void Pick::execute() {
	initialiseIteratorsFromGuiID(modifyID);
	originalTask = *currViewIter;
	doPick();
	Task::lastEditID = originalTask.getID();
	// defaultView();
	initialiseIteratorsFromGuiID(modifyID);
}

void Pick::undo() {
	isFreePeriodMode = false;
	*taskStoreIter = originalTask;
	*currViewIter = originalTask;
	Task::lastEditID = originalTask.getID();
	// defaultView();
}

std::string Pick::getMessage() {
	if (isExecuteSuccess) {
		msg = "successfully picked!";
	} else {
		msg = "reserve not picked!";
	}
	return msg;
}

//============= PICK : PRIVATE METHODS ===========

void Pick::doPick() {
	isExecuteSuccess = false;
	if (pickReserve) {
		if (taskStoreIter->getReserveStatus() == true) {
			taskStoreIter->pickReserve();
			isExecuteSuccess = true;
		}
	}
	taskStoreIter->clearReserve();

	updateTaskTypes();
	return;
}

//==================================================
//                        LOAD
//==================================================

// Load most recent file path (or default)
Load::Load() : Command(LOAD) {
	IO* io = IO::getInstance();
	filePath = io->getFilePath();
	isFreePeriodMode = false;
}

// Load new file path, which is already parsed
Load::Load(std::string newFilePath, bool isOverwriteFile) : Command(LOAD) {
	filePath = newFilePath;
	loadSuccess = true;
	isOverwriteLoadFile = isOverwriteFile;
}

Load::~Load() {}

std::string Load::getFilePath() {
	return filePath;
}

void Load::execute() {
	std::vector<Task> temp = taskStore;
	try {
		taskStore = io->loadFile(filePath,isOverwriteLoadFile); // Exception thrown if file does not exist
		History::getInstance()->clearHistory();					// Clear history after load, to avoid seg fault
		defaultView();
		Logic::setHomeMode();
	} catch (std::exception e) {
		taskStore = temp;
		loadSuccess = false;
		throw e;
	}
}

std::string Load::getMessage() {
	if (loadSuccess) {
		return "\"" + filePath + "\" loaded successfully!";
	} else {
		return "\"" + filePath + "\" does not exist";
	}
}

//==================================================
//                        SAVE
//==================================================

// Save to current file path (or default)
Save::Save() : Command(SAVE) {
	isFreePeriodMode = false;
	io = IO::getInstance();
	filePath = io->getFilePath();
}

// Save to new file path, which is already parsed
Save::Save(std::string newFilePath, bool isDeletePrevFile) : Command(SAVE) {
	filePath = newFilePath;
	isRemovePrevFile = isDeletePrevFile;
}

Save::~Save() {}

std::string Save::getFilePath() {
	return filePath;
}

void Save::execute() {
	saveSuccess = io->setFilePath(filePath,taskStore,isRemovePrevFile);
}

std::string Save::getMessage() {
	if (saveSuccess) {
		return "\"" + filePath + "\" saved successfully!";
	} else {
		return "Unable to save \"" + filePath + "\". Invalid path name.";
	}
}

//==================================================
//                        SET
//==================================================

Set::Set(std::string keyword, std::string userString) : Command(SET) {
	isFreePeriodMode = false;
	type = keyword;
	customString = userString;
}

Set::~Set() {}

void Set::execute() {
	isExecuteSuccess = false;
	if (Utilities::equalsIgnoreCase(type,"welcome")) {
		TS::MESSAGE_WELCOME = customString;
	} else if (Utilities::stringToVec(customString).size() == 1) {
		isExecuteSuccess = IO::getInstance()->setCustomCommand(type,customString);
	}
	return;
}

std::string Set::getMessage() {
	msg = "";
	if (Utilities::equalsIgnoreCase(type,"welcome")) {
		msg = "Welcome message successfully set as: " + TS::MESSAGE_WELCOME;
	} else if (isExecuteSuccess) {
		msg = "Command \"" + type + "\" successfully set as: " + customString;
	} else {
		msg = "Invalid set attempt: " + type + " " + customString;
	}
	return msg;
}

//==================================================
//                        EXIT
//==================================================

Exit::Exit() : Command(EXIT) {}

Exit::~Exit() {}

void Exit::execute() {
	IO* io = IO::getInstance();
	io->saveFile(io->getFilePath(),taskStore); // In case user or system deletes file or .TSconfig
	delete logger;
	exit(0);
}
```
###### TaskSharkInternal\Command.h
``` h
// Converted to Command Pattern by Ng Ren Zhi

#ifndef COMMAND_H_
#define COMMAND_H_

#include "IO.h"

class TS {
	// Place these in a class to allow custom Commands
	// Otherwise 'const' is needed for global strings
public:
	static bool firstLoad;
	static std::string MESSAGE_WELCOME;

	// These are the valid Command keywords
	// Count: 18
	static std::string COMMAND_ADD;
	static std::string COMMAND_DELETE;
	static std::string COMMAND_MODIFY;
	static std::string COMMAND_PICK_RESERVE;
	static std::string COMMAND_SEARCH;
	static std::string COMMAND_MARKDONE;
	static std::string COMMAND_UNMARKDONE;
	static std::string COMMAND_UNDO;
	static std::string COMMAND_REDO;
	static std::string COMMAND_VIEW;
	static std::string COMMAND_VIEW_HOME;
	static std::string COMMAND_VIEW_HOME_TS;
	static std::string COMMAND_CLEAR_ALL;
	static std::string COMMAND_DISPLAY_ALL;
	static std::string COMMAND_LOAD;
	static std::string COMMAND_SAVE;
	static std::string COMMAND_SET;
	static std::string COMMAND_EXIT;
};

enum DisplayMode {
	HOME,
	ALL,
	TODAY,
	WEEK,
	EVENTS,
	DEADLINES,
	FLOATINGS,
	SEARCHES,
	PAST_,
};

// These are the Command enums
// Count: 14 + INVALID
enum CommandType {
	ADD,
	DELETE,
	MODIFY,
	PICK,
	SEARCH,
	POWERSEARCH,
	MARKDONE,
	UNMARKDONE,
	UNDO,
	REDO,
	VIEW,
	VIEW_DEFAULT,
	CLEAR_ALL,
	DISPLAY_ALL,
	LOAD,
	SAVE,
	SET,
	EXIT,
	INVALID
};

// These are the valid View keywords
// Count: 8
const std::string VIEW_HOME = "home";
const std::string VIEW_ALL = "all";
const std::string VIEW_FLOATING = "floating";
const std::string VIEW_EVENT = "events";
const std::string VIEW_TODO = "todo";
const std::string VIEW_TODAY = "today";
const std::string VIEW_PAST = "past";
const std::string VIEW_WEEK = "week";

// These are the View enums
// Count: 10 + VIEWTYPE_INVALID
enum ViewType {
	VIEWTYPE_HOME,
	VIEWTYPE_ALL,
	VIEWTYPE_FLOATING,
	VIEWTYPE_EVENT,
	VIEWTYPE_TODO,
	VIEWTYPE_TODAY,
	VIEWTYPE_PAST,
	VIEWTYPE_WEEK,
	VIEWTYPE_PERIOD, // No keyword, triggered by heuristics
	VIEWTYPE_LABELS, // No keyword, triggered by heuristics
	VIEWTYPE_INVALID
};

class Command {
private:
	CommandType cmd;
	std::string userInput;

protected:
	static const std::string ERROR_INDEX_OUT_OF_BOUNDS;
	static const std::string ERROR_TASK_START_LATER_THAN_TASK_END;
	static const std::string ERROR_INVALID_ACTION_IN_FREE_PERIOD_MODE;

	static std::vector<Task> currentView;
	static std::vector<Task> taskStore;
	static bool isFreePeriodMode;

	TsLogger* logger;
	bool isExecuteSuccess;
	std::string invalidDateTimeString;
	std::string msg;

	//===== FOR UNDO =====
	std::vector<Task>::iterator currViewIter;
	std::vector<Task>::iterator taskStoreIter;
	int currViewPos;
	int taskStorePos;
	int uniqueID;

	bool updateCurrView();
	void updateViewIter();
	void defaultView();

	void initialiseIteratorsFromGuiID(int guiID);
	void initialiseIteratorsFromUniqueID();
	void getIterator();

	// Returns false if start is later than end, by checking date then time
	bool isDateLogical(Task task);

	void sortFloating(std::vector<Task> &taskVector);
	void sortEvent(std::vector<Task> &taskVector);
	void viewPeriod(int startDate, int EndDate, int StartTime, int EndTime);
	void sortDate(std::vector<Task> &taskVector);
	void sortDate(std::vector<Task>::iterator start, std::vector<Task>::iterator end);
	void sortTime(std::vector<Task> &taskVector);
	void sortDefault(std::vector<Task> &taskVector);
	void removeDoneTasks(std::vector<Task> & taskVector); // Removes done tasks from currentView
	void removeTaskType(std::vector<Task> &taskVector, TaskType type);
	void addPeriod(std::vector<Task> &taskVector, int startDate, int startTime, int endDate, int endTime);

	void matchIndex(int index, std::vector<Task>::iterator &currIter, 
		std::vector<Task>::iterator &taskIter);
	bool isValidIndex(int index);
	std::vector<Task>::iterator matchCurrentViewIndex(int index);
	std::vector<Task>::iterator matchTaskStoreIndex(int index);
	std::vector<Task>::iterator matchCurrentViewUniqueID(int ID);

public:
	Command(CommandType newCmd=INVALID, std::string rawInput="");
	CommandType getCommand();
	std::string getUserInput();

	static std::vector<Task> getCurrentView();
	static std::vector<Task>* getCurrentViewPtr();
	static std::vector<Task> getTaskStore();
	static int getSize();
	static void clearTaskStore();

	// To use virtual functions, declare and use a base class POINTER
	// to create a derived class object (Ren Zhi)
	virtual ~Command();
	virtual void execute();
	virtual void undo();
	virtual std::string getMessage();
};

//==================================================
//                  DERIVED COMMANDS
//==================================================

class Add: public Command {
private:
	//== EXECUTE ==
	Task newTask;
	//==== UNDO ===
	int currViewID;
	bool isOverlap;
	void checkOverlap();
	bool doAdd();
public:
	Add(Task task, std::string invalidDateTimeString="");
	~Add();
	Task getNewTask();

	void execute();
	void undo();
	std::string getMessage();
};

class Delete: public Command {
private:
	//== EXECUTE ==
	int deleteID; // ID on GUI, not taskID
	//==== UNDO ===
	Task taskToBeDeleted;

	void setUndoDeleteInfo();
	void doDelete();
public:
	Delete(int currentViewID);
	Delete(int taskID, bool undo);
	~Delete();
	int getDeleteID();

	void execute();
	void undo();
	std::string getMessage();
};

class Modify: public Command {
private:
	//== EXECUTE ==
	int modifyID; // ID on GUI, not taskID
	std::vector<FieldType> fieldsToModify;
	Task tempTask;
	bool isSetFloating;
	//==== UNDO ===
	Task originalTask;
	int prevCurrPos;

	void doModify();

	bool updateFLOATING();
	bool updateTODO();
	bool updateEVENT();
public:
	Modify(int taskID, bool isModifyFloating);
	Modify(int taskID, std::vector<FieldType> fields, Task task, std::string invalidDateTimeString="");
	Modify(CommandType pick);
	~Modify();
	int getModifyID();
	std::vector<FieldType> getFieldsToModify();
	Task getTempTask();
	void updateTaskTypes();

	void execute();
	void undo();
	std::string getMessage();
};

class Search: public Command {
private:
	//== EXECUTE ==
	std::string searchPhrase;
	//==== UNDO ===
	std::vector<Task> currentViewBeforeSearch;

	std::string doSearch();
	std::string doRegexSearch();
	bool amendView(std::string listOfIds);
public:
	Search(std::string phraseString);
	~Search();
	std::string getSearchPhrase();

	void execute();
	void undo();
	std::string getMessage();
};

class Markdone: public Command {
private:
	//== EXECUTE ==
	int doneID;
	std::string taskName;		// Added to solve iterator error for getMessage
	//==== UNDO ===
	bool successMarkDone;

	void markDone();
public:
	Markdone(int taskID);
	~Markdone();
	int getDoneID();

	void execute();
	void undo();

	std::string getMessage();
};

class UnmarkDone: public Command {
private:
	//== EXECUTE ==
	int undoneID;
	//==== UNDO ===
	bool successUnmarkDone;

	void unmarkDone();
public:
	UnmarkDone(int taskID);
	~UnmarkDone();
	int getUndoneID();

	void execute();
	void undo();

	std::string getMessage();
};

class View: public Command {
private:
	//== EXECUTE ==
	ViewType view;
	std::vector<std::string> viewLabels;
	std::vector<std::string> periodParams;
	std::string periodString;
	//==== UNDO ===
	std::vector<Task> previousView;

	bool viewHome();
	bool viewAll();
	bool viewTaskType(TaskType type);
	bool viewDone();
	bool viewToday();
	bool viewLabel(std::vector<std::string> label);

public:
	View(ViewType newView,std::string labels);
	View(std::vector<std::string> viewParameters, std::string periodInput, ViewType period=VIEWTYPE_PERIOD);
	~View();
	ViewType getViewType();

	void execute();
	void undo();

	std::string getMessage();
};

class ClearAll: public Command {
private:
	//==== UNDO ===
	std::vector<Task> previousView;

public:
	ClearAll();
	~ClearAll();

	void execute();
	void undo();

	std::string getMessage();
};

class DisplayAll: public Command {
private:
	//==== UNDO ===
	std::vector<Task> previousView;

	void formatDefaultView();
public:
	DisplayAll();
	~DisplayAll();

	void execute();
	void undo();

	std::string getMessage();
};

class Undo: public Command {
public:
	Undo();
	~Undo();

	void execute();
};

class Redo: public Command {
public:
	Redo();
	~Redo();

	void execute();
};

class Pick: public Modify {
private:
	//== EXECUTE ==
	int modifyID; // ID on GUI, not taskID
	bool pickReserve;
	//==== UNDO ===
	Task originalTask;
	int prevCurrPos;

	void doPick();

public:
	Pick(int taskID, bool isPick);
	~Pick();

	void execute();
	void undo();
	std::string getMessage();
};

class Load: public Command {
private:
	IO* io;
	std::string filePath;
	bool loadSuccess;
	bool isOverwriteLoadFile;

public:
	Load();
	Load(std::string Load,bool isOverwriteFile=true);
	~Load();
	std::string getFilePath();

	void execute();
	std::string getMessage();
};

class Save: public Command {
private:
	IO* io;
	std::string filePath;
	bool saveSuccess;
	bool isRemovePrevFile;

public:
	Save();
	Save(std::string filePath, bool isDeletePrevFile=false);
	~Save();
	std::string getFilePath();

	void execute();
	std::string getMessage();
};

class Set: public Command {
private:
	std::string type;
	std::string customString;
public:
	Set(std::string keyword, std::string userString);
	~Set();

	void execute();
	std::string getMessage();
};

class Exit: public Command {
public:
	Exit();
	~Exit();

	void execute();
};

#endif
```
###### TaskSharkInternal\IO.cpp
``` cpp

void IO::loadWelcomeMessage(std::ifstream& TSconfig) {
	std::string s;
	std::vector<std::string> commandPair;
	std::string identifier;
	std::string keyword;

	getline(TSconfig, s); // Skip newline character
	getline(TSconfig, s); // Skip blank line
	getline(TSconfig, s);
	if (s == "Welcome Message") {
		getline(TSconfig, s);
		TS::MESSAGE_WELCOME = s;
	}
	return;
}

void IO::saveWelcomeMessage(std::ofstream& TSconfig) {
	TSconfig << std::endl;
	TSconfig << "Welcome Message" << std::endl;
	TSconfig << TS::MESSAGE_WELCOME << std::endl;
	return;
}

void IO::loadCustomCommands(std::ifstream& TSconfig) {
	std::string s;
	std::vector<std::string> commandPair;
	std::string identifier;
	std::string keyword;

	// getline(TSconfig, s); // Skip newline character
	getline(TSconfig, s); // Skip blank line
	getline(TSconfig, s);
	if (s == "Custom Commands") {
		while (getline(TSconfig, s)) {
			if (!s.empty()) {
				commandPair = Utilities::stringToVec(s);
				if (commandPair.size() == 2) {
					identifier = commandPair[0];
					keyword = commandPair[1];
					setCustomCommand(identifier,keyword);
				}
			}
		}
	}
	return;
}

void IO::saveCustomCommands(std::ofstream& TSconfig) {
	TSconfig << std::endl;
	TSconfig << "Custom Commands" << std::endl;

	// Count: 16
	if ("add" != TS::COMMAND_ADD) {
		TSconfig << "add" << " " << TS::COMMAND_ADD << std::endl;
	} else if ("delete" != TS::COMMAND_DELETE) {
		TSconfig << "delete" << " " << TS::COMMAND_DELETE << std::endl;
	} else if ("modify" != TS::COMMAND_MODIFY) {
		TSconfig << "modify" << " " << TS::COMMAND_MODIFY << std::endl;
	} else if ("pick" != TS::COMMAND_PICK_RESERVE) {
		TSconfig << "pick" << " " << TS::COMMAND_PICK_RESERVE << std::endl;
	} else if ("search" != TS::COMMAND_SEARCH) {
		TSconfig << "search" << " " << TS::COMMAND_SEARCH << std::endl;
	} else if ("done" != TS::COMMAND_MARKDONE) {
		TSconfig << "done" << " " << TS::COMMAND_MARKDONE << std::endl;
	} else if ("notdone" != TS::COMMAND_UNMARKDONE) {
		TSconfig << "notdone" << " " << TS::COMMAND_UNMARKDONE << std::endl;
	} else if ("undo" != TS::COMMAND_UNDO) {
		TSconfig << "undo" << " " << TS::COMMAND_UNDO << std::endl;
	} else if ("redo" != TS::COMMAND_REDO) {
		TSconfig << "redo" << " " << TS::COMMAND_REDO << std::endl;
	} else if ("view" != TS::COMMAND_VIEW) {
		TSconfig << "view" << " " << TS::COMMAND_VIEW << std::endl;
	} else if ("clear" != TS::COMMAND_CLEAR_ALL) {
		TSconfig << "clear" << " " << TS::COMMAND_CLEAR_ALL << std::endl;
	} else if ("display" != TS::COMMAND_DISPLAY_ALL) {
		TSconfig << "display" << " " << TS::COMMAND_DISPLAY_ALL << std::endl;
	} else if ("load" != TS::COMMAND_LOAD) {
		TSconfig << "load" << " " << TS::COMMAND_LOAD << std::endl;
	} else if ("save" != TS::COMMAND_SAVE) {
		TSconfig << "save" << " " << TS::COMMAND_SAVE << std::endl;
	} else if ("exit" != TS::COMMAND_EXIT) {
		TSconfig << "exit" << " " << TS::COMMAND_EXIT << std::endl;
	}
	return;
}

bool IO::setCustomCommand(std::string identifier, std::string keyword) {
	bool isSet = false;

	if (identifier == TS::COMMAND_ADD) {
		isSet = setCommandKeyword(TS::COMMAND_ADD,keyword);
	} else if (identifier == TS::COMMAND_DELETE) {
		isSet = setCommandKeyword(TS::COMMAND_DELETE,keyword);
	} else if (identifier == TS::COMMAND_MODIFY) {
		isSet = setCommandKeyword(TS::COMMAND_MODIFY,keyword);
	} else if (identifier == TS::COMMAND_PICK_RESERVE) {
		isSet = setCommandKeyword(TS::COMMAND_PICK_RESERVE,keyword);
	} else if (identifier == TS::COMMAND_SEARCH) {
		isSet = setCommandKeyword(TS::COMMAND_SEARCH,keyword);
	} else if (identifier == TS::COMMAND_MARKDONE) {
		isSet = setCommandKeyword(TS::COMMAND_MARKDONE,keyword);
	} else if (identifier == TS::COMMAND_UNMARKDONE) {
		isSet = setCommandKeyword(TS::COMMAND_UNMARKDONE,keyword);
	} else if (identifier == TS::COMMAND_UNDO) {
		isSet = setCommandKeyword(TS::COMMAND_UNDO,keyword);
	} else if (identifier == TS::COMMAND_REDO) {
		isSet = setCommandKeyword(TS::COMMAND_REDO,keyword);
	} else if (identifier == TS::COMMAND_VIEW) {
		isSet = setCommandKeyword(TS::COMMAND_VIEW,keyword);
	} else if (identifier == TS::COMMAND_CLEAR_ALL) {
		isSet = setCommandKeyword(TS::COMMAND_CLEAR_ALL,keyword);
	} else if (identifier == TS::COMMAND_DISPLAY_ALL) {
		isSet = setCommandKeyword(TS::COMMAND_DISPLAY_ALL,keyword);
	} else if (identifier == TS::COMMAND_LOAD) {
		isSet = setCommandKeyword(TS::COMMAND_LOAD,keyword);
	} else if (identifier == TS::COMMAND_SAVE) {
		isSet = setCommandKeyword(TS::COMMAND_SAVE,keyword);
	} else if (identifier == TS::COMMAND_EXIT) {
		isSet = setCommandKeyword(TS::COMMAND_EXIT,keyword);
	}
	return isSet;
}

bool IO::setCommandKeyword(std::string &identifier, std::string keyword) {
	TsLogger::getInstance()->log(SYS,"Setting custom command...");

	// Count: 14
	if (keyword == "s"		// Protected keyword: switch between 'tile' and 'list' views
		|| keyword == "ts"	// Protected keyword: shortcut for default 'home' view
		|| keyword == "home"// Protected keyword: shortcut for default 'home' view
		|| keyword == "help"// Protected keyword: show help page
		|| keyword == "set"	// Protected keyword: set custom messages or command identifiers
		|| (&identifier != &TS::COMMAND_ADD				&& keyword == TS::COMMAND_ADD)
		|| (&identifier != &TS::COMMAND_DELETE			&& keyword == TS::COMMAND_DELETE)
		|| (&identifier != &TS::COMMAND_MODIFY			&& keyword == TS::COMMAND_MODIFY)
		|| (&identifier != &TS::COMMAND_PICK_RESERVE	&& keyword == TS::COMMAND_PICK_RESERVE)
		|| (&identifier != &TS::COMMAND_SEARCH			&& keyword == TS::COMMAND_SEARCH)
		|| (&identifier != &TS::COMMAND_MARKDONE		&& keyword == TS::COMMAND_MARKDONE)
		|| (&identifier != &TS::COMMAND_UNMARKDONE		&& keyword == TS::COMMAND_UNMARKDONE)
		|| (&identifier != &TS::COMMAND_UNDO			&& keyword == TS::COMMAND_UNDO)
		|| (&identifier != &TS::COMMAND_REDO			&& keyword == TS::COMMAND_REDO)
		|| (&identifier != &TS::COMMAND_VIEW			&& keyword == TS::COMMAND_VIEW)
		|| (&identifier != &TS::COMMAND_CLEAR_ALL		&& keyword == TS::COMMAND_CLEAR_ALL)
		|| (&identifier != &TS::COMMAND_DISPLAY_ALL		&& keyword == TS::COMMAND_DISPLAY_ALL)
		|| (&identifier != &TS::COMMAND_LOAD			&& keyword == TS::COMMAND_LOAD)
		|| (&identifier != &TS::COMMAND_SAVE			&& keyword == TS::COMMAND_SAVE)
		|| (&identifier != &TS::COMMAND_EXIT			&& keyword == TS::COMMAND_EXIT) ) {
			return false;
	}
	identifier = keyword;
	return true;
}

//========== Getter for Testing ==========

std::vector<std::string> IO::getText(std::string fileName) {
	std::ifstream inputFile(fileName);
	std::vector<std::string> textVector;

	assert(fileIsOpen(inputFile));

	while (!inputFile.eof()) {
		std::string line;
		getline(inputFile,line);

		if (line != "") {
			textVector.push_back(line);
		}
	}

	inputFile.close();
	return textVector;
}
```
###### TaskSharkInternal\Parser.cpp
``` cpp
// Parser converts flexible natural language into commands and parameters for TaskShark.

#include "stdafx.h"
#include "Parser.h"
#include "PowerSearch.h"

Parser* Parser::theOne = nullptr;

Parser::Parser() {
	logger = TsLogger::getInstance();
	logger->log(SYS,"Parser instantiated");
	// logger->setLogLevel(DEBUG);
}

Parser::~Parser() {
	logger->log(SYS,"Parser destructed");
}

// This defines the file extension used by TaskShark
const std::string Parser::FILE_EXTENSION = ".txt";

// Warnings when throwing exceptions
const std::string Parser::WARNING_INVALID_INT_STRING = "Invalid integer string: ";
const std::string Parser::WARNING_NULL_FILE_PATH	 = "No file path specified!";
const std::string Parser::WARNING_NULL_MODIFY_STRING = "No fields to modify!";
const std::string Parser::WARNING_NULL_PICK_TASK	 = "No blocked task to pick!";
const std::string Parser::WARNING_NULL_SEARCH_STRING = "No search phrase!";
const std::string Parser::WARNING_NULL_TASK_STRING	 = "No tasks to add!";

void Parser::log(Level level, std::string message) {
	logger->log(level,message);
	return;
}

void Parser::logSetTaskType(TaskType type) {
	log(DEBUG,"Setting task type as: " + Utilities::taskTypeToString(type));
	return;
}

//==================================================
//                  PUBLIC METHODS
//==================================================

Parser* Parser::getInstance() {
	if (theOne == nullptr) {
		theOne = new Parser();
	}
	return theOne;
}

std::string Parser::parseFileName(char* argv[]) {
	char* charFilePath = argv[1];
	// Replace forwardslash '/' and single backslash '\' with double backslash '\\'
	std::string newFilePath = Utilities::replace(charFilePath,"\\","\\\\");
	newFilePath = Utilities::replace(newFilePath,"/","\\\\");

	size_t fileExtensionPos = newFilePath.size() - FILE_EXTENSION.size();
	charFilePath = &newFilePath[0u];
	if (charFilePath + fileExtensionPos == FILE_EXTENSION) 	{
		newFilePath = charFilePath;
	} else {
		newFilePath = charFilePath + FILE_EXTENSION;
	}
	return newFilePath;
}

std::string Parser::parseFileName(std::string stringFilePath) {
	char* charFilePath = &stringFilePath[0u];
	char* argvForm[2]={"",charFilePath};
	return parseFileName(argvForm);
}

void Parser::createCmd(CommandType cmdType, std::string restOfInput, Command*& cmd) {
	switch (cmdType) {
	case ADD: {
			if (restOfInput == "") {
				log(WARN,WARNING_NULL_TASK_STRING);
				throw std::runtime_error(WARNING_NULL_TASK_STRING);
			}
			Task* taskPtr = parseTask(restOfInput);
			taskPtr->setID(Task::incrementRunningCount());
			cmd = new Add(*taskPtr,restOfInput);
			break; }

	case DELETE: {
			if (!Utilities::isPositiveNonZeroInt(restOfInput)) {
				log(WARN,WARNING_INVALID_INT_STRING + restOfInput);
				throw std::runtime_error(WARNING_INVALID_INT_STRING + restOfInput);
			}
			int deleteID = Utilities::stringToInt(restOfInput);
			cmd = new Delete(deleteID);
			break; }

	case MODIFY: {
			std::string tempTaskString;
			if (restOfInput == "" ||
				((tempTaskString=Utilities::removeFirstWord(restOfInput)) == "") && Task::lastEditID == 0) {
				log(WARN,WARNING_NULL_MODIFY_STRING);
				throw std::runtime_error(WARNING_NULL_MODIFY_STRING);
			}

			int modifyID = Utilities::stringToInt(Utilities::getFirstWord(restOfInput));
			if (modifyID == 0 && Task::lastEditID != 0) {
				tempTaskString = restOfInput;
			}
			if (Utilities::containsAny(tempTaskString,"float floating")) {
				bool isSetFloating = true;
				cmd = new Modify(modifyID,isSetFloating);
			} else {
				std::vector<FieldType> fieldsToModify = extractFields(restOfInput);
				Task* tempTaskPtr = parseTask(tempTaskString);
				cmd = new Modify(modifyID,fieldsToModify,*tempTaskPtr,tempTaskString);
			}
			break; }

	case PICK: {
			bool isPick = false;
			if (restOfInput == "") {
				log(WARN,WARNING_NULL_PICK_TASK);
				throw std::runtime_error(WARNING_NULL_PICK_TASK);
			}
			int pickID = Utilities::stringToInt(Utilities::getFirstWord(restOfInput));
			std::string pickString = Utilities::removeFirstWord(restOfInput);
			if (!pickString.empty() && Utilities::containsAny(pickString,"r re reserve")) {
				isPick = true;
			}
			cmd = new Pick(pickID,isPick);
			break; }

	case POWERSEARCH:
	case SEARCH: {
			if (restOfInput == "") {
				log(WARN,WARNING_NULL_SEARCH_STRING + ": " + restOfInput);
				throw std::runtime_error(WARNING_NULL_SEARCH_STRING + "!");

			} else if (isPowerSearchFormat(restOfInput)) {
				std::vector<std::string> searchParameters = parseSearchParameters(restOfInput);
				cmd = new PowerSearch(searchParameters);

			} else {
				std::string searchPhrase = restOfInput;
				cmd = new Search(searchPhrase);
			}
			break; }

	case MARKDONE: {
			if (!Utilities::isPositiveNonZeroInt(restOfInput)) {
				log(WARN,WARNING_INVALID_INT_STRING + restOfInput);
				throw std::runtime_error(WARNING_INVALID_INT_STRING + restOfInput);
			}
			int doneID = Utilities::stringToInt(restOfInput);
			cmd = new Markdone(doneID);
			break; }

	case UNMARKDONE: {
			if (!Utilities::isPositiveNonZeroInt(restOfInput)) {
				log(WARN,WARNING_INVALID_INT_STRING + restOfInput);
				throw std::runtime_error(WARNING_INVALID_INT_STRING + restOfInput);
			}
			int notdoneID = Utilities::stringToInt(restOfInput);
			cmd = new UnmarkDone(notdoneID);
			break; }

	case UNDO:
		cmd = new Undo;
		break;

	case REDO:
		cmd = new Redo;
		break;

	case VIEW: {
			log(DEBUG,"View option: " + restOfInput);
			if (restOfInput!="" && isPowerSearchKeywords(restOfInput)) {
				std::vector<std::string> searchParameters = parseSearchParameters(restOfInput);
				cmd = new View(searchParameters,restOfInput);
			} else {
				ViewType newView = Utilities::stringToViewType(restOfInput);
				cmd = new View(newView,restOfInput);
			}
			break; }

	case VIEW_DEFAULT:
		cmd = new View(VIEWTYPE_HOME,restOfInput);
		break;

	case CLEAR_ALL:
		cmd = new ClearAll;
		break;

	case DISPLAY_ALL:
		cmd = new DisplayAll;
		break;

	case LOAD: {
			if (restOfInput == "") {
				log(WARN,WARNING_NULL_FILE_PATH);
				throw std::runtime_error(WARNING_NULL_FILE_PATH);
			}
			bool isOverwriteFile = true;
			if (Utilities::containsAny(Utilities::getFirstWord(restOfInput),"from")) {
				isOverwriteFile = false;
				restOfInput = Utilities::removeFirstWord(restOfInput);
			}
			cmd = new Load(parseFileName(restOfInput),isOverwriteFile);
			break; }

	case SAVE: {
			if (restOfInput == "") {
				log(WARN,WARNING_NULL_FILE_PATH);
				throw std::runtime_error(WARNING_NULL_FILE_PATH);
			}
			bool isDeletePrevFile = false;
			if (Utilities::equalsIgnoreCase(Utilities::getFirstWord(restOfInput),"to")) {
				isDeletePrevFile = true;
				restOfInput = Utilities::removeFirstWord(restOfInput);
			}
			cmd = new Save(parseFileName(restOfInput),isDeletePrevFile);
			break; }

	case SET: {
			if (restOfInput == "") {
				log(WARN,"Nothing to set!");
				throw std::runtime_error("Nothing to set!");
			}
			std::string keyword = Utilities::getFirstWord(restOfInput);
			std::string userString = Utilities::removeFirstWord(restOfInput);
			cmd = new Set(keyword,userString);
			break; }

	case EXIT:
		cmd = new Exit;
		break;

	case INVALID:
		log(WARN,"Invalid command: " + restOfInput);
		break;
	}
}

// Throws exceptions for:
// ADD		- NullTaskString	"No tasks to add!"
// DELETE	- InvalidIntString	"Invalid integer string!"
// MODIFY	- NullModifyString	"No fields to modify!"
// SEARCH	- NullSearchString	"No search phrase!"
// MARKDONE	- InvalidIntString	"Invalid integer string!"
// LOAD		- NullFilePath		"No file path specified!"
// SAVE		- NullFilePath		"No file path specified!"
Command* Parser::parse(std::string userInput) {
	CommandType cmdType		= Utilities::stringToCmdType(Utilities::getFirstWord(userInput));
	std::string restOfInput = Utilities::removeFirstWord(userInput);
	Command*	cmd			= new Command(INVALID,userInput);
	createCmd(cmdType, restOfInput, cmd);
	return cmd;
}

//==================================================
//                 PRIVATE METHODS
//==================================================

Task* Parser::parseTask(std::string &restOfCommand) {
	log(DEBUG,"Parsing task");
	log(DEBUG,"Parsing field keyword: name");
	FieldType inputMode = NAME;

	std::vector<std::string> userInput = Utilities::stringToVec(restOfCommand);
	std::vector<std::string>::iterator curr = userInput.begin();
	std::vector<std::string> inputString;
	Task* newTask = new Task;
	bool isTODO = false;
	bool isTODOreserve = false;
	bool isReservation = false;
	std::string invalidDateTimeString = "";
	std::string errorString;

	while (curr != userInput.end() || inputMode == PRIORITY_SET) {
		inputString.clear();

		while (curr!=userInput.end() && !isFieldKeyword(*curr)) {
			inputString.push_back(*curr);
			++curr;
		}

		errorString = placeInField(newTask,isTODO,isTODOreserve,isReservation,inputMode,inputString);
		if (errorString != "") {
			if (invalidDateTimeString != "") {
				invalidDateTimeString += ", " + errorString;
			}
		}

		if (curr != userInput.end()) {
			log(DEBUG,"Parsing field keyword: " + *curr);
			inputMode = Utilities::stringToFieldType(*curr);
			++curr;
		} else {
			break;
		}
	}

	int endDate;
	if ((endDate=newTask->getEndDate()) < newTask->getStartDate()) {
		newTask->setEndDate(endDate+10000); // Set end date as next year
	}

	if (isTODO) {
		newTask->setType(TODO);
		newTask->setStartDate(newTask->getEndDate());
		newTask->setStartTime(newTask->getEndTime());
	}
	if (isTODOreserve) {
		newTask->setReserveType(TODO);
		newTask->addReserveStartDate(newTask->getReserveEndDate());
		newTask->addReserveStartTime(newTask->getReserveEndTime());
	}

	log(DEBUG,"Parsed task of type: " + Utilities::taskTypeToString(newTask->getType()));
	restOfCommand = invalidDateTimeString;
	return newTask;
}

std::vector<std::string> Parser::parseSearchParameters(std::string restOfInput) {
	std::vector<std::string> searchParameters(8);
	int newDate;
	int newTime;
	int digit;
	// Powersearch keywords: from, to, on, at, before, after, for
	std::string searchPhrase;
	int startDate = parseByDay(Utilities::stringToVec("today"));		// Allow "before"
	int startTime = TIME_NOT_SET;
	int endDate = parseByDate(Utilities::stringToVec("31 dec")) + 10000; // Allow "after"
	int endTime = TIME_NOT_SET;
	int daysNeeded = 0;
	int hoursNeeded = 1; // Default duration
	int minutesNeeded = 0;

	std::vector<std::string> userInput = Utilities::stringToVec(restOfInput);
	std::vector<std::string>::iterator curr = userInput.begin();
	std::vector<std::string> inputString;
	std::string inputMode = "searchPhrase";

	while (curr != userInput.end()) {
		inputString.clear();

		log(DEBUG,"Processing PowerSearch phrase: " + *curr);

		while (curr!=userInput.end() && !isPowerSearchKeywords(*curr)) {
			inputString.push_back(*curr);
			++curr;
		}

		if (Utilities::equalsIgnoreCase(inputMode,"searchPhrase")) {
			searchPhrase = Utilities::vecToString(inputString);
			if (searchPhrase != "") {
				hoursNeeded = 0;
			}

		} else if (Utilities::containsAny(inputMode,"from after")) {
			if ((newDate = parseDate(inputString)) != INVALID_DATE_FORMAT) {
				startDate = newDate;
			} else if ((newTime = parseTime(inputString)) != INVALID_TIME_FORMAT) {
				startTime = newTime;
			}

		} else if (Utilities::containsAny(inputMode,"to before")) {
			if ((newDate = parseDate(inputString)) != INVALID_DATE_FORMAT) {
				endDate = newDate;
			} else if ((newTime = parseTime(inputString)) != INVALID_TIME_FORMAT) {
				if (endDate == DATE_NOT_SET) {
					endDate = startDate;
				}
				endTime = newTime;
			}

		} else if (Utilities::equalsIgnoreCase(inputMode,"on")) {
			if ((newDate = parseDate(inputString)) != INVALID_DATE_FORMAT) {
				startDate = newDate;
				endDate = newDate;
			}

		} else if (Utilities::equalsIgnoreCase(inputMode,"at")) {
			if ((newTime = parseTime(inputString)) != INVALID_TIME_FORMAT) {
				if (startDate == DATE_NOT_SET) {
					startDate = parseByDay(Utilities::stringToVec("today"));
				}
				if (endDate == DATE_NOT_SET) {
					endDate = startDate;
				}
				if (startTime == TIME_NOT_SET) {
					startTime = newTime;
				} else {
					endTime = newTime;
				}
			}

		} else if (searchPhrase=="" && Utilities::equalsIgnoreCase(inputMode,"for")) {
			// Freeslot PowerSearch
			while (curr!=userInput.end() && ++curr!=userInput.end() && Utilities::isInt(*curr)) {
				digit = Utilities::stringToInt(*curr);
				if (++curr != userInput.end()) {
					if (Utilities::equalsIgnoreCase(*curr,"d")) {
						daysNeeded = digit;
						hoursNeeded = 0;
					} else if (Utilities::equalsIgnoreCase(*curr,"h")) {
						hoursNeeded = digit;
					} else if (Utilities::equalsIgnoreCase(*curr,"m")) {
						minutesNeeded = digit;
					}
				}
			}
		} else {
			break;
		}

		if (curr != userInput.end()) {
			log(DEBUG,"Parsing PowerSearch inputMode: " + *curr);
			inputMode = *curr;
			if (!Utilities::equalsIgnoreCase(inputMode,"for")) {
				++curr;
			}
		} else {
			break;
		}
	}

	if (endDate < startDate) {
		// Set end date as next year
		endDate = endDate + 10000;
	}

	if (startDate == DATE_NOT_SET) {
		startDate = parseByDay(Utilities::stringToVec("today"));
	}
	if (endDate == DATE_NOT_SET) {
		endDate = parseByDay(Utilities::stringToVec("today"));
	}
	if (startTime == TIME_NOT_SET) {
		// startTime = 0;
	}
	if (endTime == TIME_NOT_SET) {
		endTime = 2359;
	}

	searchParameters[0] = searchPhrase;
	searchParameters[1] = std::to_string(startDate);
	searchParameters[2] = std::to_string(startTime);
	searchParameters[3] = std::to_string(endDate);
	searchParameters[4] = std::to_string(endTime);
	searchParameters[5] = std::to_string(daysNeeded);
	searchParameters[6] = std::to_string(hoursNeeded);
	searchParameters[7] = std::to_string(minutesNeeded);
	log(INFO,"Parsed PowerSearch");
	return searchParameters;
}

int Parser::parseDate(std::vector<std::string> dateString) {
	int newDate;
	if (   ((newDate=parseByDate(dateString)) != INVALID_DATE_FORMAT)
		|| ((newDate=parseByDay(dateString))  != INVALID_DATE_FORMAT)) {
			return newDate;
	} else if (dateString.size()==1 && parseTime(dateString)==INVALID_TIME_FORMAT) {
		// Convert DD/MM(/YY) to DD MM( YY)
		dateString = Utilities::stringToVec(Utilities::replace(Utilities::vecToString(dateString),"/"," "));
		// Try both parseByDate and parseByDay again
		if (   ((newDate=parseByDate(dateString)) != INVALID_DATE_FORMAT)
			|| ((newDate=parseByDay(dateString))  != INVALID_DATE_FORMAT)) {
				return newDate;
		}
		// Convert DD.MM(.YY) to DD MM( YY)
		dateString = Utilities::stringToVec(Utilities::replace(Utilities::vecToString(dateString),"."," "));
		// Try both parseByDate and parseByDay again
		if (   ((newDate=parseByDate(dateString)) != INVALID_DATE_FORMAT)
			|| ((newDate=parseByDay(dateString))  != INVALID_DATE_FORMAT)) {
				return newDate;
		}
	}
	return INVALID_DATE_FORMAT;
}

// Processes dates in these formats:
// - DD MM/MMM/MMMM
int Parser::parseByDate(std::vector<std::string> dateString) {
	if (dateString.empty()) {
		return INVALID_DATE_FORMAT;
	}

	std::vector<std::string>::iterator curr;
	for (curr=dateString.begin(); curr!=dateString.end(); ++curr) {
		*curr = Utilities::stringToLower(*curr);
	}
	curr = dateString.begin();

	int dateInput = 0;
	Month monthInput = INVALID_MONTH;
	int yearInput = 0;

	int maxDays = 0;
	int newDate = INVALID_DATE_FORMAT;

	// Get dateInput
	if (curr!=dateString.end() && Utilities::isInt(*curr)) {

		dateInput = Utilities::stringToInt(*curr);
		++curr;

		// Get monthInput
		if (curr!=dateString.end()) {
			monthInput = Utilities::stringToMonth(*curr);
			if (monthInput != INVALID_MONTH) {
				maxDays = findMaxDays(monthInput);
			}
			++curr;

			// Get yearInput
			if (curr==dateString.end()) {
				yearInput = findYear();				// Get current year
			} else if (Utilities::isInt(*curr)) {
				yearInput = findYear(*curr);		// Exception thrown if year is not current or next
				++curr;
			}
			assert(yearInput>=0 && yearInput<=99);
		}
	}

	if (curr == dateString.end()
		&& yearInput != 0
		&& monthInput != INVALID_MONTH
		&& (1<=dateInput && dateInput<=maxDays)) {
			newDate = yearInput*10000 + (int)monthInput*100 + dateInput;
	}

	log(DEBUG,"Parsed by date: " + std::to_string(newDate));
	return newDate;
}

// Processes dates in these formats:
// - (this/next) DDD/DDDD
int Parser::parseByDay(std::vector<std::string> dayString) {
	if (dayString.empty()) {
		return INVALID_DATE_FORMAT;
	}

	std::vector<std::string>::iterator curr;
	for (curr=dayString.begin(); curr!=dayString.end(); ++curr) {
		*curr = Utilities::stringToLower(*curr);
	}
	curr = dayString.begin();

	int maxDays;
	int newDate = INVALID_DATE_FORMAT;

	time_t currTime = time(nullptr);
	struct tm localTime;
	localtime_s(&localTime,&currTime);
	int year = localTime.tm_year - 100;				// tm_year: years since 1990

	Month month =	(Month)(localTime.tm_mon + 1);	// tm_mon:  Jan starts at 0
	Day day =		  (Day)(localTime.tm_wday);
	int date =				localTime.tm_mday;

	if (*curr == "today" || *curr == "later") {
		++curr;
	} else if (*curr == "tmr" || *curr == "tomorrow") {
		++date;
		++curr;
	} else if (*curr == "this") {
		++curr;
	} else if (*curr == "next") {
		date += 7;
		++curr;
	}

	if (curr!=dayString.end()) {
		Day newDay = Utilities::stringToDay(*curr);
		if (newDay != INVALID_DAY) {
			date += (int)newDay - (int)day;
			++curr;
		}
	}

	if (curr == dayString.end()) {
		maxDays = findMaxDays(month,year);
		if (date>maxDays) {
			month = (Month)(((int)month)+1);
			date-=maxDays;
		}

		Month maxMonth=DEC;
		if (month>maxMonth) {
			year++;
			month = (Month)((int)month-(int)maxMonth);
		}

		// Check that valid date
		if (1<=date && date<=maxDays) {
			newDate = year*10000 + (int)month*100 + date;
		}
	}

	log(DEBUG,"Parsed by day: " + std::to_string(newDate));
	return newDate;
}

// Processes times in these formats:
// - HH    AM/PM (default: assume AM)
// - HH.MM AM/PM (default: assume AM)
// - HHMM        (24-hour)
int Parser::parseTime(std::vector<std::string> timeString) {
	if (timeString.empty() || std::count(timeString.at(0).begin(),timeString.at(0).end(),'.')>1) {
		return INVALID_TIME_FORMAT;
	}

	int time;
	int hour;
	int min = 0;
	std::string hourString;
	std::string minString;

	// Add space between joined am/pm
	timeString = Utilities::stringToVec(Utilities::replace(Utilities::vecToString(timeString),"am"," am"));
	timeString = Utilities::stringToVec(Utilities::replace(Utilities::vecToString(timeString),"pm"," pm"));

	std::vector<std::string>::iterator curr = timeString.begin();
	if (!Utilities::isPositiveNonZeroInt(*curr)) {
		size_t iSemiColon = (*curr).find('.');
		if (iSemiColon == std::string::npos) {
			return INVALID_TIME_FORMAT;
		} else {
			// HH.MM AM/PM
			hourString = (*curr).substr(0, iSemiColon);
			minString = (*curr).substr(iSemiColon + 1);
			hour = Utilities::stringToInt(hourString);
			min = Utilities::stringToInt(minString);
			if (!Utilities::isPositiveNonZeroInt(hourString) || hour >= 24
				|| !Utilities::isInt(minString) || min >= 60) {
					return INVALID_TIME_FORMAT;
			}
		}
	} else {
		time = Utilities::stringToInt(*curr);
		if (time <= 12) {
			// HH (AM/PM)
			hour = time;
		} else if (time>12 && time<24 && timeString.size()==1) {
			// HH (24-hour)
			hour = time-12;
		} else if (time <= 2359) {
			// HHMM
			hour = time/100;
			min  = time%100;
			if (hour >= 24 || min >= 60) {
				return INVALID_TIME_FORMAT;
			}
		} else {
			return INVALID_TIME_FORMAT;
		}
	}

	++curr;
	if (curr != timeString.end()) {
		if (Utilities::containsAny(*curr,"am") && hour <= 12) {
			if (hour == 12) {
				hour -= 12;
			}
		} else if (Utilities::containsAny(*curr,"pm") && hour <= 12) {
			if (hour < 12) {
				hour += 12;
			}
		} else {
			return INVALID_TIME_FORMAT;
		}
		++curr;
	}

	if (curr == timeString.end()) {
		time = hour*100 + min;
	} else {
		return INVALID_TIME_FORMAT;
	}

	log(DEBUG,"Parsed time: " + std::to_string(time));
	return time;
}

FieldType Parser::convertFieldDateToTime(FieldType &inputMode) {
	if (inputMode == START_DATE) {
		inputMode = START_TIME;
	} else if (inputMode == END_DATE) {
		inputMode = END_TIME;
	} else if (inputMode == TODO_DATE) {
		inputMode = TODO_TIME;
	}
	return inputMode;
}

void Parser::convertFieldToReserve(FieldType &inputMode) {
	if (inputMode == START_DATE) {
		inputMode = RESERVE_START_DATE;
	} else if (inputMode == START_TIME) {
		inputMode = RESERVE_START_TIME;
	} else if (inputMode == END_DATE) {
		inputMode = RESERVE_END_DATE;
	} else if (inputMode == END_TIME) {
		inputMode = RESERVE_END_TIME;
	} else if (inputMode == TODO_DATE) {
		inputMode = RESERVE_TODO_DATE;
	} else if (inputMode == TODO_TIME) {
		inputMode = RESERVE_TODO_TIME;
	}
	return;
}

std::string Parser::placeInField(Task* newTask,bool &isTODO,bool &isTODOreserve,bool &isReservation,
								 FieldType inputMode,std::vector<std::string> inputString) {
									 if (inputMode == RESERVE) {
										 isReservation = true;
										 return "";
									 }

									 log(DEBUG,"Parsing string: " + Utilities::vecToString(inputString));
									 int newDate = DATE_NOT_SET;
									 int newTime = TIME_NOT_SET;

									 if (isDateField(inputMode)) {
										 newDate = parseDate(inputString);
										 if (newDate == INVALID_DATE_FORMAT) {
											 newTime = parseTime(inputString);
											 if(newTime == INVALID_DATE_FORMAT) {
												 std::string invalidDateTimeString = Utilities::vecToString(inputString);
												 return invalidDateTimeString;
											 } else {
												 convertFieldDateToTime(inputMode);
											 }
										 }

										 if (!isReservation) {
											 if (/*newTask->getType()==FLOATING &&*/ isTodoField(inputMode)) {
												 isTODO = true;
											 } else if (isTODO && inputMode==START_TIME) {
												 inputMode = TODO_TIME;
											 }
										 } else if (isReservation) {
											 log(DEBUG,"Parsing reservation: " + Utilities::vecToString(inputString));
											 if (newTask->getReserveType()==FLOATING && isTodoField(inputMode)) {
												 isTODOreserve = true;
											 } else if (isTODOreserve && inputMode==START_TIME) {
												 inputMode = TODO_TIME;
											 }
											 convertFieldToReserve(inputMode);
										 }
									 }

									 switch (inputMode) {
									 case NAME:
										 newTask->setName(Utilities::vecToString(removeSlashKeywords(inputString)));
										 break;
									 case LABELS_ADD:
										 newTask->addLabels(removeSlashKeywords(inputString));
										 break;
									 case LABELS_DELETE:
										 newTask->setLabelsToDelete(removeSlashKeywords(inputString));
										 break;
									 case LABELS_CLEAR:
										 // Nothing to set
										 break;
									 case PRIORITY_SET:
										 newTask->setPriority();
										 break;
									 case PRIORITY_UNSET:
										 // Unset by default
										 break;
									 case START_DATE:
										 logSetTaskType(EVENT);
										 newTask->setType(EVENT);
										 newTask->setStartDate(newDate);
										 if (newTask->getEndDate() == DATE_NOT_SET) {
											 newTask->setEndDate(newDate);
										 }
										 break;
									 case TODO_DATE:
									 case END_DATE:
										 if (newTask->getType() == FLOATING) {
											 logSetTaskType(TODO);
											 isTODO = true;
										 } else if (isTODO
											 || (newTask->getType()==EVENT && newTask->getStartDate()==DATE_NOT_SET)) {
												 newTask->setStartDate(newDate);
										 }
										 newTask->setEndDate(newDate);
										 break;
									 case START_TIME:
										 logSetTaskType(EVENT);
										 newTask->setType(EVENT);
										 if ((newTime = parseTime(inputString)) != INVALID_TIME_FORMAT) {
											 if (newTask->getStartTime() == TIME_NOT_SET) {
												 newTask->setStartTime(newTime);
											 }
										 } else {
											 break;
										 }
									 case TODO_TIME:
									 case END_TIME:
										 if ((newTime = parseTime(inputString)) != INVALID_TIME_FORMAT) {
											 if (newTask->getStartDate() == DATE_NOT_SET) {
												 if (newTask->getEndDate() == DATE_NOT_SET) {
													 newTask->setStartDate(parseByDay(Utilities::stringToVec("today")));
												 } else {
													 newTask->setStartDate(newTask->getEndDate());
												 }
											 }
											 if (newTask->getEndDate() == DATE_NOT_SET) {
												 newTask->setEndDate(newTask->getStartDate());
											 }

											 newTask->setEndTime(newTime);
											 if (newTask->getStartTime()!=TIME_NOT_SET && newTask->getStartTime()!=newTask->getEndTime()) {
												 logSetTaskType(EVENT);
												 newTask->setType(EVENT);
											 } else if (newTask->getType()==EVENT && newTask->getStartTime()==TIME_NOT_SET) {
												 newTask->setStartTime(newTime);
											 } else if (newTask->getType()==FLOATING) {
												 logSetTaskType(TODO);
												 isTODO = true;
											 }
										 }
										 break;
										 //===== Reservation: Follow above and modify accordingly =====
									 case RESERVE_START_DATE:
										 log(DEBUG,"Placing in reserveStartDate");
										 newTask->setReserveType(EVENT);
										 newTask->addReserveStartDate(newDate);
										 break;
									 case RESERVE_TODO_DATE:
									 case RESERVE_END_DATE:
										 log(DEBUG,"Placing in reserveEndDate");
										 if (newTask->getReserveType() == FLOATING) {
											 isTODOreserve = true;
										 } else if (isTODOreserve
											 || (newTask->getReserveType()==EVENT && newTask->getReserveStartDate()==DATE_NOT_SET)) {
												 newTask->addReserveStartDate(newDate);
										 }
										 newTask->addReserveEndDate(newDate);
										 break;
									 case RESERVE_START_TIME:
										 log(DEBUG,"Placing in reserveStartTime");
										 newTask->setReserveType(EVENT);
										 if ((newTime = parseTime(inputString)) != INVALID_TIME_FORMAT) {
											 if (newTask->getReserveStartTime() == TIME_NOT_SET) {
												 newTask->addReserveStartTime(newTime);
											 }
										 } else {
											 break;
										 }
									 case RESERVE_TODO_TIME:
									 case RESERVE_END_TIME:
										 log(DEBUG,"Placing in reserveEndTime");
										 if ((newTime = parseTime(inputString)) != INVALID_TIME_FORMAT) {
											 if (newTask->getReserveStartDate() == DATE_NOT_SET) {
												 if (newTask->getReserveEndDate() == DATE_NOT_SET) {
													 newTask->addReserveStartDate(parseByDay(Utilities::stringToVec("today")));
												 } else {
													 newTask->addReserveStartDate(newTask->getReserveEndDate());
												 }
											 }
											 if (newTask->getReserveEndDate() == DATE_NOT_SET) {
												 newTask->addReserveEndDate(newTask->getReserveStartDate());
											 }
											 newTask->addReserveEndTime(newTime);
											 if (   newTask->getReserveStartTime() != TIME_NOT_SET
												 && newTask->getReserveStartTime() != newTask->getReserveEndTime()) {
													 newTask->setReserveType(EVENT);
											 } else if (newTask->getReserveType()==EVENT && newTask->getReserveStartTime()==TIME_NOT_SET) {
												 newTask->addReserveStartTime(newTime);
											 } else if (newTask->getReserveType()==FLOATING) {
												 isTODOreserve = true;
											 }
										 }
										 break;
									 case RESERVE:
										 //===== Reservation: Follow end =====
									 case INVALID_FIELD:
										 break;
									 }
									 return "";
}

int Parser::findMaxDays(Month month, int year) { // default year is 2015
	int maxDays = 0;
	bool isLeap;
	switch (month) {
	case JAN:
	case MAR:
	case MAY:
	case JUL:
	case AUG:
	case OCT:
	case DEC:
		maxDays = 31;
		break;
	case APR:
	case JUN:
	case SEP:
	case NOV:
		maxDays = 30;
		break;
	case FEB:
		isLeap = ((year%4==0 && year%100!=0) || year%400==0);
		if (isLeap) {
			maxDays = 29;
		} else {
			maxDays = 28;
		}
	case INVALID_MONTH:
		break;
	}
	return maxDays;
}

// Returns year in YY
// Throws exception if invalid yearString
int Parser::findYear(std::string yearString) {
	time_t t = time(nullptr);		// Get current time
	struct tm now;
	localtime_s(&now,&t);
	int year = now.tm_year - 100;	// Get current year, tm_year: years since 1900

	if (yearString == "") {
		return year;
	} else if (Utilities::isPositiveNonZeroInt(yearString)) {
		if (Utilities::stringToInt(yearString) == year
			|| Utilities::stringToInt(yearString) == 2000+year) {
				return year;
		} else if (Utilities::stringToInt(yearString) == year+1
			|| Utilities::stringToInt(yearString) == 2000+year+1) {
				return year+1;
		}
	} else {
		throw std::runtime_error("Invalid year string: " + yearString + "\n");
	}
	return year;
}

// Powersearch (keywords: from, to, at, on, before, after, for)
bool Parser::isPowerSearchKeywords(std::string str) {
	assert(str!="");
	std::string powerSearchKeywords = "from to at on before after for";
	return Utilities::containsAny(str,powerSearchKeywords);
}

// - Searchphrase
//		e.g. search lab      from mon at     1 pm to tue at 2 pm
//		e.g. search lecture  on   tue wed 3 pm
//		e.g. search tutorial on   wed thu  4 pm
// - Freeslot  (keyword: for)
//		e.g. search                   from   8 am        to 2 pm for 1 h 
bool Parser::isPowerSearchFormat(std::string searchStrings) {
	assert(searchStrings!="");
	std::string searchPhrase = Utilities::getFirstWord(searchStrings);

	if (isPowerSearchKeywords(searchStrings)) {
		if (!isPowerSearchKeywords(searchPhrase)) {
			return true;	// Searchphrase (takes precedence over Freeslot powersearch)
		} else if (Utilities::containsAny(searchStrings,"for")) {
			return true;	// Freeslot
		}
	}
	return false;
}

bool Parser::isFieldKeyword(std::string str) {
	return Utilities::stringToFieldType(str)!=INVALID_FIELD;
}

bool Parser::isDateField(FieldType field) {
	return (field==START_DATE || field==END_DATE || field==TODO_DATE);
}

bool Parser::isTodoField(FieldType field) {
	return (field==TODO_DATE || field==TODO_TIME);
}

std::vector<FieldType> Parser::extractFields(std::string restOfInput) {
	assert(restOfInput != "");
	std::vector<std::string> vecInput = Utilities::stringToVec(restOfInput);
	std::vector<std::string>::iterator curr = vecInput.begin();
	std::vector<FieldType> fields;

	if (Utilities::isInt(*curr)){
		++curr;
	}

	if (Utilities::stringToFieldType(*curr) == INVALID_FIELD) {
		fields.push_back(NAME);
	}

	FieldType newField;
	std::vector<std::string>::iterator end;
	while (curr != vecInput.end()) {
		newField = Utilities::stringToFieldType(*curr);
		if (newField == LABELS_DELETE
			&& curr+1 != vecInput.end()
			&& Utilities::stringToFieldType(*(curr+1)) != INVALID_FIELD) {
				fields.push_back(LABELS_CLEAR);
		} else if (isDateField(newField) && curr+1 != vecInput.end()) {
			end = curr+2;
			if (curr+2 != vecInput.end()) {
				end = curr+3;
			}
			if (parseDate(std::vector<std::string>(curr+1,end)) == INVALID_DATE_FORMAT
				&& parseTime(std::vector<std::string>(curr+1,end)) != INVALID_TIME_FORMAT) {
					fields.push_back(convertFieldDateToTime(newField));
			} else if (parseDate(std::vector<std::string>(curr+1,end)) != INVALID_DATE_FORMAT) {
				fields.push_back(newField);
			}
		} else if (newField != INVALID_FIELD) {
			fields.push_back(newField);
		}
		++curr;
	}

	log(DEBUG,"Fields extracted: " + Utilities::fieldVecToString(fields));
	return fields;
}

std::vector<std::string> Parser::removeSlashKeywords(std::vector<std::string> vecString) {
	std::vector<std::string>::iterator curr;
	std::string subString;
	for (curr=vecString.begin(); curr!=vecString.end(); ++curr) {
		if ( ((*curr)[0] == '/' || (*curr)[0] == '\\') && isFieldKeyword(subString = (*curr).substr(1)) ) {
			*curr = subString;
		}
	}
	return vecString;
}
```
###### TaskSharkInternal\Parser.h
``` h
// Parser converts flexible natural language into commands and parameters for TaskShark.

#ifndef PARSER_H_
#define PARSER_H_

class Parser {
private:
	static Parser* theOne;
	Parser();

	TsLogger* logger;
	void log(Level level, std::string message);
	void logSetTaskType(TaskType type);

	// This defines the file extension used by TaskShark
	static const std::string FILE_EXTENSION;

	static const std::string WARNING_INVALID_INT_STRING;
	static const std::string WARNING_NULL_FILE_PATH;
	static const std::string WARNING_NULL_MODIFY_STRING;
	static const std::string WARNING_NULL_PICK_TASK;
	static const std::string WARNING_NULL_SEARCH_STRING;
	static const std::string WARNING_NULL_TASK_STRING;

	// These are the return values for invalid parameters
	static const int INVALID_DATE_FORMAT = -1;
	static const int INVALID_TIME_FORMAT = -1;

	int findMaxDays(Month month, int year=2015);
	int findYear(std::string yearString="");

	bool isPowerSearchKeywords(std::string str);
	bool isPowerSearchFormat(std::string searchStrings);
	bool isFieldKeyword(std::string str);
	bool isDateField(FieldType field);
	bool isTodoField(FieldType field);

	std::string placeInField(Task* newTask, bool &isTODO, bool &isTODOreserve, bool &isReservation,
		FieldType inputMode, std::vector<std::string> inputString);	

	FieldType convertFieldDateToTime(FieldType &inputMode);
	void convertFieldToReserve(FieldType &inputMode);
	void createCmd(CommandType cmdType, std::string restOfInput, Command*& cmd);
	std::vector<FieldType>		extractFields(std::string restOfInput);
	std::vector<std::string>	removeSlashKeywords(std::vector<std::string> vecString);

public:
	Task* parseTask(std::string &restOfCommand);
	std::vector<std::string> parseSearchParameters(std::string restOfInput);
	int parseDate(std::vector<std::string> dateString);
	int parseByDate(std::vector<std::string> dateString);
	int parseByDay(std::vector<std::string> dayString);
	int parseTime(std::vector<std::string> timeString);

	// This is the API
	~Parser();
	static Parser* getInstance();
	std::string parseFileName(char* argv[]);
	std::string parseFileName(std::string stringFilePath);

	Command* parse(std::string userInput);
};

#endif
```
###### TaskSharkInternal\Task.cpp
``` cpp

#include "stdafx.h"

int Task::runningCount = 0;
int Task::lastEditID = 0;

Task::Task() {
	name = "";
	type = FLOATING;
	uniqueID = 0;
	labels = std::set<std::string>();

	isDone = false;
	isPriority = false;

	startDate = DATE_NOT_SET;	// YYMMDD, supports 2015-2099
	startTime = TIME_NOT_SET;	// HHMM, 24-hour format
	endDate = DATE_NOT_SET;
	endTime = TIME_NOT_SET;

	reserveStartDate = std::set<int>();
	reserveStartTime = std::set<int>();
	reserveEndDate = std::set<int>();
	reserveEndTime = std::set<int>();
}

Task::~Task() {}

//========== Static ==========

int Task::getRunningCount() {
	return runningCount;
}

void Task::setRunningCount(int lastCount) {
	runningCount = lastCount;
}

int Task::incrementRunningCount() {
	return ++runningCount;
}

//========== Getters ==========

std::string Task::getName() {
	return name;
}

TaskType Task::getType() {
	return type;
}

int Task::getID() {
	return uniqueID;
}

std::vector<std::string> Task::getLabelsToDelete() {
	return labelsToDelete;
}

bool Task::getDoneStatus() {
	return isDone;
}

bool Task::getPriorityStatus() {
	return isPriority;
}

int Task::getStartDate() {
	return startDate;
}

int Task::getStartTime() {
	return startTime;
}

int Task::getEndDate() {
	return endDate;
}

int Task::getEndTime() {
	return endTime;
}

TaskType Task::getReserveType() {
	return reserveType;
}

int Task::getReserveStartDate() {
	if (reserveStartDate.empty()) {
		return DATE_NOT_SET;
	}
	int date = *(reserveStartDate.begin());
	return date;
}

int Task::getReserveStartTime() {
	if (reserveStartTime.empty()) {
		return TIME_NOT_SET;
	}
	int time = *(reserveStartTime.begin());
	return time;
}

int Task::getReserveEndDate() {
	if (reserveEndDate.empty()) {
		return DATE_NOT_SET;
	}
	int date = *(reserveEndDate.begin());
	return date;
}

int Task::getReserveEndTime() {
	if (reserveEndTime.empty()) {
		return TIME_NOT_SET;
	}
	int time = *(reserveEndTime.begin());
	return time;
}

bool Task::getReserveStatus() {
	if (   !reserveStartDate.empty()
		|| !reserveStartTime.empty()
		|| !reserveEndDate.empty()
		|| !reserveEndTime.empty()) {
			return true;
	}
	return false;
}

void Task::setReserveType(TaskType newType) {
	reserveType = newType;
	return;
}

void Task::addReserveStartDate(int newReservation) {
	reserveStartDate.clear();
	reserveStartDate.insert(newReservation);
	return;
}

void Task::addReserveStartTime(int newReservation) {
	reserveStartTime.clear();
	reserveStartTime.insert(newReservation);
	return;
}

void Task::addReserveEndDate(int newReservation) {
	reserveEndDate.clear();
	reserveEndDate.insert(newReservation);
	return;
}

void Task::addReserveEndTime(int newReservation) {
	reserveEndTime.clear();
	reserveEndTime.insert(newReservation);
	return;
}

void Task::pickReserve() {
	startDate = getReserveStartDate();
	startTime = getReserveStartTime();
	endDate = getReserveEndDate();
	endTime = getReserveEndTime();
	return;
}

void Task::clearReserve() {
	reserveStartDate.clear();
	reserveStartTime.clear();
	reserveEndDate.clear();
	reserveEndTime.clear();
	return;
}

std::vector<std::string> Task::getLabels() {
	std::vector<std::string> labelVector;
	std::set<std::string>::iterator i = labels.begin();
	while (i != labels.end()) {
		labelVector.push_back(*i);
		++i;
	}
	return labelVector;
}

std::string Task::getLabelString() {
	std::string label;
	std::set<std::string>::iterator i = labels.begin();
	while (i != labels.end()) {
		label = label + *i + " ";
		++i;
	}
	if (!label.empty()) {
		label.pop_back();
	}
	return label;
}

std::string Task::getDisplayDate() {
	std::string date;
	if (startDate == DATE_NOT_SET) {
		date = "";
	} else if (startDate == endDate) {
		date = Utilities::toDisplayDate(startDate);
	} else if (startDate != endDate) {
		date = Utilities::toDisplayDate(startDate) + " - " + Utilities::toDisplayDate(endDate);
	}

	if (getReserveStatus() == true) {
		date += "\n";
		if (reserveStartDate == reserveEndDate) {
			date += Utilities::toDisplayDate(getReserveStartDate());
		} else {
			date += Utilities::toDisplayDate(getReserveStartDate()) + " - " +
				Utilities::toDisplayDate(getReserveEndDate());
		}
	}
	return date;
}

std::string Task::getDisplayTime() {
	std::string time;
	if (endTime == TIME_NOT_SET) {
		time = "";
	} else if (startTime == TIME_NOT_SET || startTime == endTime) {
		time = Utilities::toDisplayTime(endTime);
	} else if (startTime != endTime) {
		time = Utilities::toDisplayTime(startTime) + " - " + Utilities::toDisplayTime(endTime);;
	}

	if (getReserveStatus() == true) {
		time += "\n";
		if (reserveStartTime == reserveEndTime) {
			time += Utilities::toDisplayTime(getReserveStartTime());
		} else {
			time += Utilities::toDisplayTime(getReserveStartTime()) + " - " +
				Utilities::toDisplayTime(getReserveEndTime());
		}
	}
	return time;
}

//========== Setters ==========
// Return true if successful

bool Task::setName(std::string newName) {
	name = newName;
	return true;
}

bool Task::setType(TaskType newType) {
	type = newType;
	return true;
}

bool Task::setID(int newID) {
	uniqueID = newID;
	return true;
}

bool Task::addLabels(std::vector<std::string> newLabels) {
	std::vector<std::string>::iterator curr;
	for (curr=newLabels.begin(); curr!=newLabels.end(); ++curr) {
		labels.insert(*curr);
	}
	return true;
}

bool Task::deleteLabels(std::vector<std::string> badLabels) {
	std::vector<std::string>::iterator badCurr;
	std::set<std::string>::iterator labelsCurr;
	for (badCurr=badLabels.begin(); badCurr!=badLabels.end(); ++badCurr) {
		for (labelsCurr=labels.begin();labelsCurr!=labels.end(); ++labelsCurr) {
			if (Utilities::equalsIgnoreCase(*badCurr,*labelsCurr)) {
				labelsCurr = labels.erase(labelsCurr);
				if (labelsCurr == labels.end()) {
					break;
				}
			}
		}
	}
	return true;
}

bool Task::setLabelsToDelete(std::vector<std::string> oldLabels) {
	labelsToDelete = oldLabels;
	return true;
}

bool Task::clearLabels() {
	if (labels.empty()) {
		return false;
	}
	labels.clear();
	return true;
}

bool Task::markDone() {
	bool currDone = !isDone;
	isDone = true;
	return currDone;
}

bool Task::unmarkDone() {
	bool currDone = isDone;
	isDone = false;
	return currDone;
}

bool Task::setPriority() {
	return isPriority != (isPriority=true);
}

bool Task::unsetPriority() {
	return isPriority == (isPriority=false);;
}

bool Task::setStartDate(int newStartDate) {
	startDate = newStartDate;
	return true;
}

bool Task::setStartTime(int newStartTime) {
	startTime = newStartTime;
	return true;
}

bool Task::setEndDate(int newEndDate) {
	endDate = newEndDate;
	return true;
}

bool Task::setEndTime(int newEndTime) {
	endTime = newEndTime;
	return true;
}

void Task::resetDatesAndTimes() {
	startDate = DATE_NOT_SET;
	startTime = TIME_NOT_SET;
	endDate = DATE_NOT_SET;
	endTime = TIME_NOT_SET;
	return;
}

bool Task::isUrgent() {
	if (type == FLOATING) {
		return false;
	}

	int day	  = startDate % 100;
	int month = (startDate % 10000)/100;
	int year  = startDate/10000;

	struct tm now;
	time_t t = time(nullptr);
	localtime_s(&now,&t);

	struct tm taskDate = {0,0,0,day,month-1,year+100}; 
	std::time_t a = std::mktime(&taskDate);
	std::time_t b = std::mktime(&now);

	int difference = std::difftime(a, b) / (60 * 60 * 24);
	if((type == TODO && difference < 4)) {
		return true;
	} 
	return false;
}

bool Task::isToday() {
	int currentDay = Utilities::getLocalDay();
	int currentMonth = Utilities::getLocalMonth();
	int currentYear = Utilities::getLocalYear();

	int day = startDate % 100;
	int month = (startDate % 10000)/100;
	int year = startDate/10000;

	if (day == currentDay && month == currentMonth && year == currentYear) {
		return true;
	} 
	return false;
}

// For testing
bool Task::tasksAreEqual(Task task1, Task task2) {
	if (    (task1.getDoneStatus() != task2.getDoneStatus())
		|| (task1.getEndDate() != task2.getEndDate())
		|| (task1.getEndTime() != task2.getEndTime())
		|| (task1.getID() != task2.getID())
		|| (task1.getLabelString() != task2.getLabelString())
		|| (task1.getName() != task2.getName())
		|| (task1.getPriorityStatus() != task2.getPriorityStatus())
		|| (task1.getStartDate() != task2.getStartDate())
		|| (task1.getStartTime() != task2.getStartTime())
		|| (task1.getType() != task2.getType())) {
			return false;
	}
	return true;
}
```
###### TaskSharkInternal\Task.h
``` h

#ifndef TASK_H_
#define TASK_H_

// This is the default initialisation for date and time
const int DATE_NOT_SET = 0;
const int TIME_NOT_SET = -1;	// 0 represents "12 am"

// These are the valid Field keywords
// Count: 10
const std::string FIELD_NAME = "name";
const std::string FIELD_LABEL_ADD = ":";
const std::string FIELD_LABEL_DELETE = "-:";
const std::string FIELD_PRIORITY_SET = "star";
const std::string FIELD_PRIORITY_UNSET = "unstar";
const std::string FIELD_DATE_FROM = "from";
const std::string FIELD_DATE_TO = "to";
const std::string FIELD_DATE_BY = "by";
const std::string FIELD_DATE_ON = "on";
const std::string FIELD_TIME_AT = "at";
const std::string FIELD_RESERVE_SWITCH = "reserve";

// These are the Field enums
// Count: 10 + 2 TODO + INVALID_FIELD
enum FieldType {
	NAME,
	LABELS_ADD,
	LABELS_DELETE,
	LABELS_CLEAR,
	PRIORITY_SET,
	PRIORITY_UNSET,
	START_DATE,
	START_TIME,
	END_DATE,
	END_TIME,
	TODO_DATE,
	TODO_TIME,
	RESERVE,
	RESERVE_START_DATE,
	RESERVE_START_TIME,
	RESERVE_END_DATE,
	RESERVE_END_TIME,
	RESERVE_TODO_DATE,
	RESERVE_TODO_TIME,
	INVALID_FIELD,
};

enum Day {
	SUN,
	MON, TUE, WED,
	THU, FRI, SAT,
	INVALID_DAY
};

enum Month {
	INVALID_MONTH,
	JAN, FEB, MAR,
	APR, MAY, JUN,
	JUL, AUG, SEP,
	OCT, NOV, DEC
};

enum TaskType {
	FLOATING,
	EVENT,
	TODO
};

class Task {
private:
	static int runningCount;

	std::string name;
	TaskType type;
	int uniqueID;

	std::set<std::string> labels;
	std::vector<std::string> labelsToDelete;

	bool isDone;
	bool isPriority;

	int startDate; // YYMMDD, supports 2015-2099
	int startTime; // HHMM, 24-hour format
	int endDate;
	int endTime;

	TaskType reserveType;
	std::set<int> reserveStartDate;	// Currently only holds 1 reservation
	std::set<int> reserveStartTime;	// Currently only holds 1 reservation
	std::set<int> reserveEndDate;	// Currently only holds 1 reservation
	std::set<int> reserveEndTime;	// Currently only holds 1 reservation

public:
	static int lastEditID;

	static int getRunningCount();
	static int incrementRunningCount();					// For new tasks
	static void setRunningCount(int lastCount);			// For startup
	static bool tasksAreEqual(Task task1, Task task2);	// For testing

	Task();
	~Task();

	// Getters
	std::string getName();
	TaskType getType();
	int getID();
	std::string getLabelString();
	std::vector<std::string> getLabels();
	std::vector<std::string> getLabelsToDelete();

	bool getDoneStatus();
	bool getPriorityStatus();

	int getStartDate();
	int getStartTime();
	int getEndDate();
	int getEndTime();

	TaskType getReserveType();
	int getReserveStartDate();
	int getReserveStartTime();
	int getReserveEndDate();
	int getReserveEndTime();
	bool getReserveStatus();

	std::string getDisplayDate();
	std::string getDisplayTime();

	// Setters, return true if successful
	bool setName(std::string newName);
	bool setType(TaskType newType);
	bool setID(int newID);

	bool addLabels(std::vector<std::string> newLabels);
	bool deleteLabels(std::vector<std::string> badLabels);
	bool setLabelsToDelete(std::vector<std::string> oldLabels);
	bool clearLabels();

	bool markDone();		// Returns false if already done
	bool unmarkDone();		// Returns false if already not done

	bool setPriority();		// Returns false if already priority
	bool unsetPriority();	// Returns false if already not priority

	bool setStartDate(int newStartDate);
	bool setStartTime(int newStartTime);
	bool setEndDate(int newEndDate);
	bool setEndTime(int newEndTime);
	void resetDatesAndTimes();

	void setReserveType(TaskType newType);
	void addReserveStartDate(int newReservation);
	void addReserveStartTime(int newReservation);
	void addReserveEndDate(int newReservation);
	void addReserveEndTime(int newReservation);
	void pickReserve();

	void clearReserve();

	bool isUrgent();
	bool isToday();
};

#endif
```
###### TaskSharkInternal\TsLogger.cpp
``` cpp

#include "stdafx.h"

const std::string TsLogger::logFileName = ".tslog";

TsLogger* TsLogger::theOne = new TsLogger();

TsLogger::TsLogger() {
	logLevel = INFO;
	log(SYS,"Logger initialised");
	log(SYS,"Log level default: " + std::to_string(logLevel));
}

TsLogger::~TsLogger() {
	log(SYS,"Logger terminated\n");
}

char* TsLogger::getLocalTime() {
	time_t rawtime;
	time(&rawtime);

	struct tm *timeinfo = new tm;
	localtime_s(timeinfo, &rawtime);

	char* buffer = new char[26];
	asctime_s(buffer,26,timeinfo);
	buffer[strlen(buffer)-1]=0;
	return buffer;
}

int TsLogger::getDate() {
	time_t rawtime = time(nullptr);		// Get current time
	struct tm dayinfo;
	localtime_s(&dayinfo,&rawtime);

	int year =	dayinfo.tm_year - 100;	// tm_year: years since 1990
	int month =	dayinfo.tm_mon + 1;		// tm_mon:  Jan starts at 0
	int day =	dayinfo.tm_mday;
	int date = year*10000 + month*100 + day;
	return date;
}

TsLogger* TsLogger::getInstance() {
	return theOne;
}

void TsLogger::setLogLevel(Level level) {
	if (logLevel != level) {
		log(SYS,"Log level changed from " + std::to_string(logLevel) + " to "+ std::to_string(level));
		logLevel = level;
	}
	return;
}

void TsLogger::log(Level level, std::string message) {
	if (level >= logLevel) {
		std::ofstream logfile;
		logfile.open(logFileName, std::ofstream::out | std::ofstream::app);
		logfile << getLocalTime() << " " << message << std::endl;
		logfile.close();
	}
	return;
}

void TsLogger::clearLog() {
	remove(logFileName.c_str());
	log(SYS,"Log cleared");
	log(SYS,"Logger initialised");
	log(SYS,"Log level default: " + std::to_string(logLevel));
	return;
}

void TsLogger::close() {
	log(SYS,"Logger closed");
	delete theOne;
	return;
}

// Currently disabled
/*
bool TsLogger::setLogFileName(std::string fileName) {
std::ofstream newLogFile;
newLogFile.open(fileName, std::ofstream::out | std::ofstream::app);

if (newLogFile.is_open()) {
newLogFile.close();

log(FATAL,"TsLogger closed");

logFileName = fileName;
log(FATAL,"TsLogger initiated");
return true;
}
return false;
}
*/
```
###### TaskSharkInternal\TsLogger.h
``` h
//
//========== Setup for your Component Class ==========
// Declare in header file as private member of the component class:
//		TsLogger* logger;
//
// Initialise in cpp file in constructor, change ### to class name:
//		logger = TsLogger::getInstance();
//		logger->setLogLevel(DEBUG);
//		logger->log(SYS,"### instantiated");
//
// Include in cpp file in destructor, change ### to class name:
//		logger->log(SYS,"### destructed");
//
// Add in cpp file as private method, change ### to class name:
//		void ###::log(Level level, std::string message) {
//		logger->log(level,message);
//		return;
//		}
//
// Use in cpp file in methods, refer to enum for Level options:
//		log(Level,std::string);
//

#ifndef LOGGER_H_
#define LOGGER_H_

enum Level {
	DEBUG,	// set this when debugging
	INFO,	// default
	SYS,	// system information for when components are instantiated and destructed
	WARN,	// error that will not stop the application from running
	FATAL	// very severe error that will presumably lead the application to abort
};

class TsLogger {
private:
	static const std::string logFileName;
	static TsLogger* theOne;
	Level logLevel;
	TsLogger();

public:
	char* getLocalTime();
	static TsLogger* getInstance();
	~TsLogger();

	void setLogLevel(Level level);
	void log(Level level, std::string message);
	int getDate();
	void clearLog();
	void close();

	// Currently disabled
	// bool setLogFileName(std::string fileName);
};

#endif
```
###### TaskSharkInternal\Utilities.cpp
``` cpp
// Methods are listed in order of return type, then alphabetical order

#include "stdafx.h"

Utilities::Utilities() {}
Utilities::~Utilities() {}

//==================================================
//                     CONVERTERS
//==================================================

//========== Int-to-Type Converters ==========
std::set<int> Utilities::intToSet(int num) {
	std::set<int> set;
	set.insert(num);
	return set;
}

//========== String-to-Type Converters ==========

std::string Utilities::stringToLower(std::string str) {
	std::transform(str.begin(), str.end(), str.begin(), ::tolower);
	return str;
}

int Utilities::stringToInt(std::string str) {
	char c;
	int i = 0;
	std::stringstream ss(str);
	ss >> i;
	if (ss.fail() || ss.get(c)) {
		return LAST_TASK_INDICATOR;
	} else {
		return i;
	}
}

CommandType Utilities::stringToCmdType(std::string str) {
	CommandType cmd;
	std::ostringstream address;
	address << (void*)&TS::COMMAND_ADD;
	std::string name = address.str();

	if (equalsIgnoreCase(str, TS::COMMAND_ADD))	{
		cmd = ADD;
	} else if (equalsIgnoreCase(str, TS::COMMAND_DELETE)) {
		cmd = DELETE;
	} else if (equalsIgnoreCase(str, TS::COMMAND_MODIFY)) {
		cmd = MODIFY;
	} else if (equalsIgnoreCase(str, TS::COMMAND_PICK_RESERVE)) {
		cmd = PICK;
	} else if (equalsIgnoreCase(str, TS::COMMAND_SEARCH)) {
		cmd = SEARCH;
	} else if (equalsIgnoreCase(str, TS::COMMAND_MARKDONE)) {
		cmd = MARKDONE;
	} else if (equalsIgnoreCase(str, TS::COMMAND_UNMARKDONE)) {
		cmd = UNMARKDONE;
	} else if (equalsIgnoreCase(str, TS::COMMAND_UNDO)) {
		cmd = UNDO;
	} else if (equalsIgnoreCase(str, TS::COMMAND_REDO)) {
		cmd = REDO;
	} else if (equalsIgnoreCase(str, TS::COMMAND_VIEW)) {
		cmd = VIEW;
	} else if (equalsIgnoreCase(str, TS::COMMAND_VIEW_HOME) || equalsIgnoreCase(str, TS::COMMAND_VIEW_HOME_TS)) {
		cmd = VIEW_DEFAULT;
	} else if (equalsIgnoreCase(str, TS::COMMAND_CLEAR_ALL)) {
		cmd = CLEAR_ALL;
	} else if (equalsIgnoreCase(str, TS::COMMAND_DISPLAY_ALL)) {
		cmd = DISPLAY_ALL;
	} else if (equalsIgnoreCase(str, TS::COMMAND_LOAD)) {
		cmd = LOAD;
	} else if (equalsIgnoreCase(str, TS::COMMAND_SAVE)) {
		cmd = SAVE;
	} else if (equalsIgnoreCase(str, TS::COMMAND_SET)) {
		cmd = SET;
	} else if (equalsIgnoreCase(str, TS::COMMAND_EXIT)) {
		cmd = EXIT;
	} else {
		cmd = INVALID;
	}
	return cmd;
}

Day Utilities::stringToDay(std::string dayString) {
	Day day = INVALID_DAY;

	if (containsAny(dayString,"sun sunday")) {
		day = SUN;
	} else if (containsAny(dayString,"mon monday")) {
		day = MON;
	} else if (containsAny(dayString,"tue tues tuesday")) {
		day = TUE;
	} else if (containsAny(dayString,"wed wednesday")) {
		day = WED;
	} else if (containsAny(dayString,"thu thur thurs thursday")) {
		day = THU;
	} else if (containsAny(dayString,"fri friday")) {
		day = FRI;
	} else if (containsAny(dayString,"sat saturday")) {
		day = SAT;
	}
	return day;
}

Month Utilities::stringToMonth(std::string monthString) {
	Month monthInput = INVALID_MONTH;

	if (containsAny(monthString,"1 jan january")) {
		monthInput = JAN;
	} else if (containsAny(monthString,"2 feb february")) {
		monthInput = FEB;
	} else if (containsAny(monthString,"3 mar march")) {
		monthInput = MAR;
	} else if (containsAny(monthString,"4 apr april")) {
		monthInput = APR;
	} else if (containsAny(monthString,"5 may")) {
		monthInput = MAY;
	} else if (containsAny(monthString,"6 jun june")) {
		monthInput = JUN;
	} else if (containsAny(monthString,"7 jul july")) {
		monthInput = JUL;
	} else if (containsAny(monthString,"8 aug august")) {
		monthInput = AUG;
	} else if (containsAny(monthString,"9 sep sept september")) {
		monthInput = SEP;
	} else if (containsAny(monthString,"10 oct october")) {
		monthInput = OCT;
	} else if (containsAny(monthString,"11 nov november")) {
		monthInput = NOV;
	} else if (containsAny(monthString,"12 dec december")) {
		monthInput = DEC;
	}
	return monthInput;
}

FieldType Utilities::stringToFieldType(std::string fieldString) {
	FieldType field;

	if (equalsIgnoreCase(fieldString,FIELD_NAME)) {
		field = NAME;
	} else if (equalsIgnoreCase(fieldString,FIELD_LABEL_ADD)) {
		field = LABELS_ADD;
	} else if (equalsIgnoreCase(fieldString,FIELD_LABEL_DELETE)) {
		field = LABELS_DELETE;
	} else if (equalsIgnoreCase(fieldString,FIELD_PRIORITY_SET)) {
		field = PRIORITY_SET;
	} else if (equalsIgnoreCase(fieldString,FIELD_PRIORITY_UNSET)) {
		field = PRIORITY_UNSET;
	} else if (equalsIgnoreCase(fieldString,FIELD_DATE_ON)) {
		field = START_DATE;
	} else if (equalsIgnoreCase(fieldString,FIELD_DATE_FROM)) {
		field = START_DATE;
	} else if (equalsIgnoreCase(fieldString,FIELD_DATE_TO)) {
		field = END_DATE;
	} else if (equalsIgnoreCase(fieldString,FIELD_DATE_BY)) {
		field = TODO_DATE;
	} else if (equalsIgnoreCase(fieldString,FIELD_TIME_AT)) {
		field = START_TIME;
	} else if (equalsIgnoreCase(fieldString,FIELD_RESERVE_SWITCH)) {
		field = RESERVE;
	} else {
		field = INVALID_FIELD;
	}
	return field;
}

TaskType Utilities::stringToTaskType(std::string taskString) {
	TaskType type = FLOATING;

	if (taskString == "FLOATING") {
		type = FLOATING;
	} else if (taskString == "EVENT") {
		type = EVENT;
	} else if (taskString == "TODO") {
		type = TODO;
	}
	return type;
}

ViewType Utilities::stringToViewType(std::string viewString) {
	ViewType view;

	if (viewString == "") {
		view = VIEWTYPE_INVALID;
	} else if (equalsIgnoreCase(viewString,VIEW_HOME)) {
		view = VIEWTYPE_HOME;
	} else if (equalsIgnoreCase(viewString,VIEW_ALL)) {
		view = VIEWTYPE_ALL;
	} else if (equalsIgnoreCase(viewString,VIEW_FLOATING)) {
		view = VIEWTYPE_FLOATING;
	} else if (equalsIgnoreCase(viewString,VIEW_EVENT)) {
		view = VIEWTYPE_EVENT;
	} else if (equalsIgnoreCase(viewString,VIEW_TODO)) {
		view = VIEWTYPE_TODO;
	} else if (equalsIgnoreCase(viewString,VIEW_TODAY)) {
		view = VIEWTYPE_TODAY;
	} else if (equalsIgnoreCase(viewString,VIEW_PAST)) {
		view = VIEWTYPE_PAST;
	} else if (equalsIgnoreCase(viewString,VIEW_WEEK)) {
		view = VIEWTYPE_WEEK;
	} else {
		view = VIEWTYPE_LABELS;
	}
	return view;
}

std::vector<std::string> Utilities::stringToVec(std::string str) {
	std::vector<std::string> tokens;
	std::istringstream iss(str);
	std::copy(std::istream_iterator<std::string>(iss),
		std::istream_iterator<std::string>(),
		std::back_inserter<std::vector<std::string>>(tokens));
	return tokens;
}

//========== Type-to-String Converters ==========

std::string Utilities::boolToString(bool boolean) {
	if (boolean) {
		return "true";
	} else {
		return "false";
	}
}

std::string Utilities::intToString(int num) {
	return std::to_string(num);
}

std::string Utilities::dayToString(Day day) {
	std::string dayString;

	switch(day) {
	case SUN:
		dayString = "Sunday";
		break;
	case MON:
		dayString = "Monday";
		break;
	case TUE:
		dayString = "Tuesday";
		break;
	case WED:
		dayString = "Wednesday";
		break;
	case THU:
		dayString = "Thursday";
		break;
	case FRI:
		dayString = "Friday";
		break;
	case SAT:
		dayString = "Saturday";
		break;
	case INVALID_DAY:
		dayString = "INVALID_DAY";
		break;
	}
	return dayString;
}

std::string Utilities::monthToString(Month month) {
	std::string monthString;

	switch (month) {
	case JAN:
		monthString = "Jan";
		break;
	case FEB:
		monthString = "Feb";
		break;
	case MAR:
		monthString = "Mar";
		break;
	case APR:
		monthString = "Apr";
		break;
	case MAY:
		monthString = "May";
		break;
	case JUN:
		monthString = "June";
		break;
	case JUL:
		monthString = "Jul";
		break;
	case AUG:
		monthString = "Aug";
		break;
	case SEP:
		monthString = "Sep";
		break;
	case OCT:
		monthString = "Oct";
		break;
	case NOV:
		monthString = "Nov";
		break;
	case DEC:
		monthString = "Dec";
		break;
	case INVALID_MONTH:
		break;
	}
	return monthString;
}

std::string Utilities::fieldVecToString(std::vector<FieldType> fields) {
	std::vector<FieldType>::iterator curr = fields.begin();
	std::string newString;

	while (curr != fields.end()) {
		switch(*curr) {
		case NAME:
			newString += FIELD_NAME;
			break;
		case LABELS_ADD:
			newString += FIELD_LABEL_ADD;
			break;
		case LABELS_DELETE:
			newString += FIELD_LABEL_DELETE;
			break;
		case LABELS_CLEAR:
			newString += "LABELS_CLEAR";
			break;
		case PRIORITY_SET:
			newString += FIELD_PRIORITY_SET;
			break;
		case PRIORITY_UNSET:
			newString += FIELD_PRIORITY_UNSET;
			break;
		case START_DATE:
			newString += FIELD_DATE_FROM;
			break;
		case START_TIME:
			newString += FIELD_TIME_AT;
			break;
		case END_DATE:
			newString += FIELD_DATE_TO;
			break;
		case END_TIME:
			newString += "FIELD_END_TIME";
			break;
		case TODO_DATE:
		case TODO_TIME:
			newString += FIELD_DATE_BY;
			break;
		case INVALID_FIELD:
			newString += "FIELD_INVALID";
			break;
		case RESERVE:
		case RESERVE_START_DATE:
		case RESERVE_START_TIME:
		case RESERVE_END_DATE:
		case RESERVE_END_TIME:
		case RESERVE_TODO_DATE:
		case RESERVE_TODO_TIME:
			newString += "FIELD_RESERVE";
			break;
		}

		if (++curr != fields.end()) {
			newString += " ";
		}
	}
	return newString;
}

std::string Utilities::taskToString(Task task) {
	const int MAX_BYTES = 2550;
	char buffer[MAX_BYTES] = "";

	sprintf_s(buffer, "%s%s\n%s%s\n%s%s\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n",
		"Name: ",		task.getName().c_str(),						// %s%s\n
		"Type: ",		taskTypeToString(task.getType()).c_str(),	// %s%s\n
		"Labels: ",		task.getLabelString().c_str(),				// %s%s\n
		"Done: ",		task.getDoneStatus(),						// %s%d\n
		"Priority: ",	task.getPriorityStatus(),					// %s%d\n
		"Start Date: ",	task.getStartDate(),						// %s%d\n
		"Start Time: ",	task.getStartTime(),						// %s%d\n
		"End Date: ",	task.getEndDate(),							// %s%d\n
		"End Time: ",	task.getEndTime()							// %s%d\n
		);
	return buffer;
}

std::string Utilities::taskTypeToString(TaskType type) {
	std::string typeString;

	switch(type) {
	case FLOATING:
		typeString = "FLOATING";
		break;
	case EVENT:
		typeString = "EVENT";
		break;
	case TODO:
		typeString = "TODO";
		break;
	}
	return typeString;
}

std::string Utilities::vecToString(std::vector<std::string> vecString) {
	std::string newString;
	std::vector<std::string>::iterator curr;
	for (curr=vecString.begin(); curr!=vecString.end(); ) {
		newString += *curr;
		if (++curr != vecString.end()) {
			newString += " ";
		}
	}
	return newString;
}

std::string	Utilities::viewTypeToString(ViewType view) {
	std::string viewString;

	switch(view) {
	case VIEWTYPE_HOME:
		viewString = VIEW_HOME;
		break;
	case VIEWTYPE_ALL:
		viewString = VIEW_ALL;
		break;
	case VIEWTYPE_FLOATING:
		viewString = VIEW_FLOATING;
		break;
	case VIEWTYPE_EVENT:
		viewString = VIEW_EVENT;
		break;
	case VIEWTYPE_TODO:
		viewString = VIEW_TODO;
		break;
	case VIEWTYPE_TODAY:
		viewString = VIEW_TODAY;
		break;
	case VIEWTYPE_PAST:
		viewString = VIEW_PAST;
		break;
	case VIEWTYPE_WEEK:
		viewString = VIEW_WEEK;
		break;
	case VIEWTYPE_PERIOD:
		viewString = "VIEW_PERIOD";
		break;
	case VIEWTYPE_LABELS:
		viewString = VIEW_WEEK;
		break;
	case VIEWTYPE_INVALID:
		viewString = "VIEW_INVALID";
		break;
	}

	return viewString;
}

//==================================================
//             COMPARISONS AND MODIFIERS
//==================================================

bool Utilities::containsAny(std::string words1, std::string words2) {
	words1 = stringToLower(words1);
	words2 = stringToLower(words2);
	std::vector<std::string> vecWords1 = stringToVec(words1);
	std::vector<std::string> vecWords2 = stringToVec(words2);
	std::vector<std::string>::iterator curr1;
	std::vector<std::string>::iterator curr2;

	for (curr1=vecWords1.begin(); curr1!=vecWords1.end(); ++curr1) {
		for (curr2=vecWords2.begin(); curr2!=vecWords2.end(); ++curr2) {
			if (*curr1 == *curr2) {
				return true;
			}
		}
	}
	return false;
}

bool Utilities::isInt(std::string str) {
	return !(str.empty()) && str.find_first_not_of("0123456789")==std::string::npos;
}

// Credits: Adapted from CityConnect.cpp (CS2103 Tutorial 2)
```
###### TaskSharkInternal\Utilities.h
``` h
// Methods are listed in order of return type, then alphabetical order

#ifndef UTILITIES_H_
#define UTILITIES_H_

// This is the return value for invalid numbers
const int INVALID_NUMBER_FORMAT = -1;
const int LAST_TASK_INDICATOR = 0;

class Utilities {
private:
	// No public constructors and destructors, since Utilities is not an object
	Utilities();
	~Utilities();

public:
	//========== Int-to-Type Converters ==========
	static std::set<int>	intToSet(int num);
	//========== String-to-Type Converters ==========
	static std::string	stringToLower(std::string str);
	static int			stringToInt(std::string str);
	static CommandType	stringToCmdType(std::string str);
	static Day			stringToDay(std::string dayString);
	static Month		stringToMonth(std::string monthString);
	static FieldType	stringToFieldType(std::string fieldString);
	static TaskType		stringToTaskType(std::string typeString);
	static ViewType		stringToViewType(std::string viewString);
	static std::vector<std::string> stringToVec(std::string str);
	//========== Type-to-String Converters ==========
	static std::string	boolToString(bool boolean);
	static std::string	intToString(int num);
	static std::string	dayToString(Day day);
	static std::string  monthToString(Month month);
	static std::string	taskToString(Task task);
	static std::string	taskTypeToString(TaskType type);
	static std::string	fieldVecToString(std::vector<FieldType> fields);
	static std::string	vecToString(std::vector<std::string> vecString);
	static std::string	viewTypeToString(ViewType view);

	//========== Comparisons and Modifiers ==========
	static bool			containsAny(std::string searchWord, std::string words);
	static bool			isInt(std::string str);
	static bool			isSubstring(std::string subString, std::string word);
	// Strict weak ordering function for isSubstring()
	static bool			equalsIgnoreCase_char(char l, char r); 
	// Credits: Adapted from CityConnect.cpp (CS2103 Tutorial 2)
```
###### TaskSharkTests\IOTest.cpp
``` cpp
	TEST_CLASS(SetFilePathTest) {
public:
	Parser* parser;
	IO* io;
	Task task;
	std::vector<Task> taskVector;
	std::string userInput;
	std::string newFilePath;

	TEST_METHOD_INITIALIZE(GetInstanceForParserAndIO) {
		parser = Parser::getInstance();
		io = IO::getInstance();
	}

	TEST_METHOD(IO_setFilePath_parentDirectory) {
		userInput = "dummy";
		task = *parser->parseTask(userInput);
		userInput = "../test";
		newFilePath = parser->parseFileName(userInput);
		Assert::AreEqual(true,io->setFilePath(newFilePath,taskVector));

		// Remove file created
		remove(newFilePath.c_str());
	}

	TEST_METHOD(IO_setFilePath_parentOfParentDirectory) {
		userInput = "dummy";
		task = *parser->parseTask(userInput);
		userInput = "../../test";
		newFilePath = parser->parseFileName(userInput);
		Assert::AreEqual(true,io->setFilePath(newFilePath,taskVector));

		// Remove file created
		remove(newFilePath.c_str());
	}

	TEST_METHOD(IO_setFilePath_userDirectory) {
		userInput = "dummy";
		task = *parser->parseTask(userInput);
		userInput = "C:/Users/Public/TEXT";
		newFilePath = parser->parseFileName(userInput);
		Assert::AreEqual(true,io->setFilePath(newFilePath,taskVector));

		// Remove file created
		remove(newFilePath.c_str());
	}

	};
}
```
###### TaskSharkTests\ParserTest.cpp
``` cpp

#include "stdafx.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace TaskSharkTests {
	TEST_CLASS(ParserTest) {
public:
	// Declare common variables to be used in tests
	TsLogger* logger;
	Parser* p;
	Command* cmd;
	Task task;

	std::string				 userInput;
	std::vector<std::string> inputVec;
	std::string				 expectedString;
	int						 expectedInt;
	static const int		 INVALID_DATE_FORMAT = -1;

	TEST_CLASS_INITIALIZE(StartTestClass) {
		TsLogger::getInstance()->clearLog();
	}

	TEST_METHOD_INITIALIZE(GetInstanceLoggerAndParser) {
		logger = TsLogger::getInstance();
		p = Parser::getInstance();
	}

	TEST_METHOD_CLEANUP(EndTestMethod) {
		TsLogger::getInstance()->log(SYS,"Test ended\n");
	}

	TEST_METHOD(Parser_parseFileName) {
		//===== Normal =====
		userInput = "test.txt";
		Assert::AreEqual(userInput,p->parseFileName(userInput));

		//===== No file extension =====
		expectedString = "test.txt";
		userInput = "test";
		Assert::AreEqual(expectedString,p->parseFileName(userInput));

		//===== Single forward slash =====
		expectedString = "\\\\test.txt";
		userInput = "/test.txt";
		Assert::AreEqual(expectedString,p->parseFileName(userInput));

		//===== Single backslash =====
		// Note: Seen as double here because '\' is a reserved character
		expectedString = "C:\\\\Users\\\\%USERNAME%\\\\Downloads\\\\TEXT.txt";
		userInput = "C:\\Users\\%USERNAME%\\Downloads\\TEXT.txt";
		Assert::AreEqual(expectedString,p->parseFileName(userInput));
	}

	TEST_METHOD(Parser_parse_Add) {
		cmd->clearTaskStore();
		Add* add;
		size_t storeSizeBeforeAdd;

		//===== EVENT with multipleWordsName, endDate and endTime =====
		userInput = "add A partridge in a pear tree on sat by 8 pm";
		cmd = p->parse(userInput);
		add = (Add*)cmd;
		storeSizeBeforeAdd = add->getTaskStore().size();
		add->execute();
		task = add->getTaskStore().back();
		Assert::AreEqual(storeSizeBeforeAdd+1, add->getTaskStore().size());
		Assert::AreEqual(std::string("A partridge in a pear tree"),task.getName());
		Assert::AreEqual(std::string("TODO"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151114, task.getStartDate());
		Assert::AreEqual(2000, task.getStartTime());
		Assert::AreEqual(151114, task.getEndDate());
		Assert::AreEqual(2000, task.getEndTime());

		//===== EVENT with singleWordName, startDate and endDate =====
		userInput = "Add that from 14 Oct to 16 Oct";
		cmd = p->parse(userInput);
		add = (Add*)cmd;
		storeSizeBeforeAdd = add->getTaskStore().size();
		add->execute();
		task = add->getNewTask();
		Assert::AreEqual(storeSizeBeforeAdd+1, add->getTaskStore().size());
		Assert::AreEqual(std::string("that"),task.getName());
		Assert::AreEqual(std::string("EVENT"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151014, task.getStartDate());
		// Assert::AreEqual(TIME_NOT_SET, task.getStartTime());
		Assert::AreEqual(151016, task.getEndDate());
		// Assert::AreEqual(TIME_NOT_SET, task.getEndTime());

		//===== EVENT with singleWordName, startTime and endTime =====
		userInput = "Add fishing from 12 am to 11.59 pm";
		cmd = p->parse(userInput);
		add = (Add*)cmd;
		storeSizeBeforeAdd = add->getTaskStore().size();
		add->execute();
		task = add->getNewTask();
		Assert::AreEqual(storeSizeBeforeAdd+1, add->getTaskStore().size());
		Assert::AreEqual(std::string("fishing"),task.getName());
		Assert::AreEqual(std::string("EVENT"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		// Assert::AreEqual(0, task.getStartDate());
		Assert::AreEqual(0, task.getStartTime());
		// Assert::AreEqual(0, task.getEndDate());
		Assert::AreEqual(2359, task.getEndTime());
	}

	void logicProcessCommandStub(Command* cmd,
		Task &task,
		int &taskID,
		std::vector<FieldType> &fieldsToModify,
		std::string &searchPhrase) {
			CommandType cmdType = cmd->getCommand();

			switch(cmdType) {
			case ADD:
				task = ((Add*)cmd)->getNewTask();
				break;
			case DELETE:
				taskID = ((Delete*)cmd)->getDeleteID();
				break;
			case MODIFY:
				taskID = ((Modify*)cmd)->getModifyID();
				fieldsToModify = ((Modify*)cmd)->getFieldsToModify();
				logger->log(DEBUG,"Fields to modify: " + Utilities::fieldVecToString(fieldsToModify));
				task = ((Modify*)cmd)->getTempTask();
				break;
			case SEARCH:
				searchPhrase = ((Search*)cmd)->getSearchPhrase();
				break;
			case POWERSEARCH:
			case PICK:
			case MARKDONE:		// Mark task as done
			case UNMARKDONE:	// Mark task as not done
			case UNDO:			// Undo last command if ADD, DELETE or MODIFY or MARKDONE
			case REDO:			// Redo last undo, if any
			case VIEW:			// Process view
			case CLEAR_ALL:		// Clear all tasks
			case DISPLAY_ALL:	// Display all tasks
			case LOAD:			// Load file
			case SAVE:			// Save to new file path
			case EXIT:			// Exit program
			case INVALID:		// Return error message to UI
				break;
			}
	}

	TEST_METHOD(Parser_parse_Delete) {
		expectedInt = 1;
		userInput = "delete 1";
		cmd = p->parse(userInput);
		Delete* deleteCmd = (Delete*)cmd;
		Assert::AreEqual(expectedInt,deleteCmd->getDeleteID());
	}

	TEST_METHOD(Parser_parse_Modify) {
		Task task;
		Add add(task);
		add.execute();
		add.execute();
		add.execute();
		/*
		expectedInt = 1;
		expectedString = "Name: Two turtle doves\nType: 1\nStart Time: 800\nEnd Date: 151024\nEnd Time: 800\n";
		userInput = "modify 1 Two turtle doves : label1 -: unlabel1 star dummy unstar dummy from today to tmr on fri by sat at 8 am";
		*/
		expectedInt = 3;
		expectedString = ": star";
		userInput = "modify 3 : star";

		Command* cmd = p->parse(userInput);
				
		int taskID = 0;
		std::vector<FieldType> fieldsToModify;
		std::string searchPhrase;

		logicProcessCommandStub(cmd,task,taskID,fieldsToModify,searchPhrase);

		Assert::AreEqual(expectedInt,taskID);
		Assert::AreEqual(expectedString,Utilities::fieldVecToString(fieldsToModify));
		// Assert::AreEqual(expectedString2,Utilities::taskToString(task));
	}

	TEST_METHOD(Parser_parse_nonCRUD) {
		//===== Test for SEARCH =====
		expectedString = "answerToLife";
		userInput = "search answerToLife";

		cmd = p->parse(userInput);
		int taskID = 0;
		std::vector<FieldType> fieldsToModify;
		std::string searchPhrase;

		logicProcessCommandStub(cmd,task,taskID,fieldsToModify,searchPhrase);

		//==================================================
		//          TEST-ASSERTING OUTPUT OF PARSE()
		//==================================================
		CommandType cmdType = cmd->getCommand();
		switch(cmdType) {
		case ADD:		// Use TEST_METHOD(Parser_parse_Add)
		case DELETE:	// Use TEST_METHOD(Parser_parse_Delete)
		case MODIFY:	// Use TEST_METHOD(Parser_parse_Modify)
			break;
		case SEARCH:
			Assert::AreEqual(expectedString,searchPhrase);
			break;
		case POWERSEARCH:
		case PICK:
		case MARKDONE:
		case UNMARKDONE:
		case UNDO:
		case REDO:
		case VIEW:
		case CLEAR_ALL:
		case DISPLAY_ALL:
		case LOAD:
		case SAVE:
		case EXIT:
		case INVALID:
			break;
		}
	}

	// Note: As parseByDate() takes in regex like "this Monday",
	//       test cases are only valid for ONE week each time!
	TEST_METHOD(Parser_parseByDate) {
		// Invalid date formats
		expectedInt = INVALID_DATE_FORMAT;

		userInput = "";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDate(inputVec));

		userInput = "invalid";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDate(inputVec));

		userInput = "1 invalid";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDate(inputVec));

		userInput = "7 pm";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDate(inputVec));

		// Valid date formats
		expectedInt = 151231;
		userInput = "31 dec";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDate(inputVec));

		userInput = "31 dec 15";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDate(inputVec));
	}

	TEST_METHOD(Parser_parseByDay) {
		// Invalid date formats
		expectedInt = INVALID_DATE_FORMAT;

		userInput = "7 pm";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDate(inputVec));

		// Change to appropriate date for today/tmr before running this test
		/*
		expectedInt = 151018;
		userInput = "today";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDay(inputVec));

		expectedInt = 151019;
		userInput = "tmr";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDay(inputVec));
		*/

		expectedInt = 151109;
		userInput = "mon";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDay(inputVec));

		expectedInt = 151114;
		userInput = "this sat";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDay(inputVec));

		expectedInt = 151115;
		userInput = "next sun";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseByDay(inputVec));
	}

	TEST_METHOD(Parser_parseTask) {
		//===== TODO with endDate =====
		expectedString = "Name: Sing a song\nType: TODO\nLabels: \nDone: 0\nPriority: 0\nStart Date: 151231\nStart Time: -1\nEnd Date: 151231\nEnd Time: -1\n";
		userInput = "Sing a song by 31 dec";
		task = *(p->parseTask(userInput));
		Assert::AreEqual(expectedString,Utilities::taskToString(task));
		Assert::AreEqual(std::string("Sing a song"),task.getName());
		Assert::AreEqual(std::string("TODO"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151231, task.getStartDate());
		Assert::AreEqual(TIME_NOT_SET, task.getStartTime());
		Assert::AreEqual(151231, task.getEndDate());
		Assert::AreEqual(TIME_NOT_SET, task.getEndTime());

		//===== EVENT with startDate and endDate =====
		expectedString = "Name: Sing a song\nType: EVENT\nLabels: \nDone: 0\nPriority: 0\nStart Date: 151231\nStart Time: -1\nEnd Date: 160101\nEnd Time: -1\n";
		userInput = "Sing a song from 31 dec to 1 jan";
		task = *(p->parseTask(userInput));
		Assert::AreEqual(expectedString,Utilities::taskToString(task));
		Assert::AreEqual(std::string("Sing a song"),task.getName());
		Assert::AreEqual(std::string("EVENT"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151231, task.getStartDate());
		// ::AreEqual(TIME_NOT_SET, task.getStartTime());
		Assert::AreEqual(160101, task.getEndDate());
		// Assert::AreEqual(TIME_NOT_SET, task.getEndTime());

		//===== EVENT with startDate, startTime, endDate, endTime =====
		userInput = "Camp from fri at 6 pm to next sun at 4 pm";
		task = *(p->parseTask(userInput));
		Assert::AreEqual(std::string("Camp"),task.getName());
		Assert::AreEqual(std::string("EVENT"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(151113, task.getStartDate());
		Assert::AreEqual(1800, task.getStartTime());
		Assert::AreEqual(151115, task.getEndDate());
		Assert::AreEqual(1600, task.getEndTime());

		//===== (Modify) FLOATING with emptyAddLabels and setPriority =====
		expectedString = "Name: \nType: FLOATING\nLabels: \nDone: 0\nPriority: 1\nStart Date: 0\nStart Time: -1\nEnd Date: 0\nEnd Time: -1\n";
		userInput = ": star";
		task = *(p->parseTask(userInput));
		Assert::AreEqual(expectedString,Utilities::taskToString(task));
		Assert::AreEqual(std::string(""),task.getName());
		Assert::AreEqual(std::string("FLOATING"),Utilities::taskTypeToString(task.getType()));
		// Assert::AreEqual(std::string(""),task.getLabelString());
		// Assert::AreEqual(false,task.getDoneStatus());
		// Assert::AreEqual(false,task.getPriorityStatus());
		Assert::AreEqual(DATE_NOT_SET, task.getStartDate());
		Assert::AreEqual(TIME_NOT_SET, task.getStartTime());
		Assert::AreEqual(DATE_NOT_SET, task.getEndDate());
		Assert::AreEqual(TIME_NOT_SET, task.getEndTime());
	}

	TEST_METHOD(Parser_parseTime) {
		// Invalid time formats
		expectedInt = -1;

		userInput = "invalid";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "0";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "0.";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = ".0";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "0.0";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "0.1";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "2400";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "2360";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "24.00";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "23.60";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "23.59 am";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		userInput = "23.59 pm";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		// Valid time formats

		expectedInt = 100;
		userInput = "100";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		expectedInt = 2359;
		userInput = "23.59";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		expectedInt = 0;
		userInput = "12 am";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		expectedInt = 0;
		userInput = "12.00 am";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		expectedInt = 100;
		userInput = "1.00 am";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		expectedInt = 1159;
		userInput = "11.59 am";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		expectedInt = 1200;
		userInput = "12 pm";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));

		expectedInt = 1200;
		userInput = "12.00 pm";
		inputVec = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedInt,p->parseTime(inputVec));
	}

	// - Searchphrase
	//		e.g. search lab      from mon at     1 pm to tue at 2 pm
	//		e.g. search lecture  on   wed before 3 pm
	//		e.g. search tutorial on   thu after  4 pm
	// - Freeslot  (keyword: for)
	//		e.g. search                   from   8 am        to 2 pm for 1 h 
	TEST_METHOD(Parser_parseSearchParameters) {
		Command::clearTaskStore();
		int today = p->parseByDay(Utilities::stringToVec("today"));
		int defaultEndDate = p->parseByDate(Utilities::stringToVec("31 dec")) + 10000;
		std::vector<std::string> searchParameters;
		std::vector<std::string>::iterator param;

		std::vector<std::string> holder(8);
		std::vector<std::string>::iterator curr = holder.begin();
		std::vector<std::string>::iterator searchPhrase = curr++;
		std::vector<std::string>::iterator startDate = curr++;
		std::vector<std::string>::iterator startTime = curr++;
		std::vector<std::string>::iterator endDate = curr++;
		std::vector<std::string>::iterator endTime = curr++;
		std::vector<std::string>::iterator daysNeeded = curr++;
		std::vector<std::string>::iterator hrsNeeded = curr++;
		std::vector<std::string>::iterator minsNeeded = curr;

		// Searchphrase PowerSearch with startDate, startTime, endDate,endTime
		// Tested: from, at, to
		userInput = "lab from mon at 1 pm to tue at 2 pm";
		searchParameters = p->parseSearchParameters(userInput);
		for (curr=holder.begin(),param=searchParameters.begin(); curr!=holder.end(); curr++,param++) {
			*curr = *param;
		}
		Assert::AreEqual(std::string("lab"),*searchPhrase);
		Assert::AreEqual(151109,Utilities::stringToInt(*startDate));
		Assert::AreEqual(1300,Utilities::stringToInt(*startTime));
		Assert::AreEqual(151110,Utilities::stringToInt(*endDate));
		Assert::AreEqual(1400,Utilities::stringToInt(*endTime));
		Assert::AreEqual(0,Utilities::stringToInt(*daysNeeded));
		Assert::AreEqual(0,Utilities::stringToInt(*hrsNeeded));
		Assert::AreEqual(0,Utilities::stringToInt(*minsNeeded));

		// Searchphrase PowerSearch with startDate, startTime, endDate,endTime
		// Tested: after, before
		userInput = "lecture on wed after 3 pm before 4 pm";
		searchParameters = p->parseSearchParameters(userInput);
		for (curr=holder.begin(),param=searchParameters.begin(); curr!=holder.end(); curr++,param++) {
			*curr = *param;
		}
		Assert::AreEqual(std::string("lecture"),*searchPhrase);
		Assert::AreEqual(151111,Utilities::stringToInt(*startDate));
		Assert::AreEqual(1500,Utilities::stringToInt(*startTime));
		Assert::AreEqual(151111,Utilities::stringToInt(*endDate));
		Assert::AreEqual(1600,Utilities::stringToInt(*endTime));
		Assert::AreEqual(0,Utilities::stringToInt(*daysNeeded));
		Assert::AreEqual(0,Utilities::stringToInt(*hrsNeeded));
		Assert::AreEqual(0,Utilities::stringToInt(*minsNeeded));

		// Freeslot Powersearch with daysNeeded and minsNeeded, so hrs corrected to 0
		// Tested: for, d, m
		userInput = "for 1 d 1 m";
		searchParameters = p->parseSearchParameters(userInput);
		for (curr=holder.begin(),param=searchParameters.begin(); curr!=holder.end(); curr++,param++) {
			*curr = *param;
		}
		Assert::AreEqual(std::string(""),*searchPhrase);
		Assert::AreEqual(today,Utilities::stringToInt(*startDate));
		Assert::AreEqual(TIME_NOT_SET,Utilities::stringToInt(*startTime));
		Assert::AreEqual(defaultEndDate,Utilities::stringToInt(*endDate));
		Assert::AreEqual(2359,Utilities::stringToInt(*endTime));
		Assert::AreEqual(1,Utilities::stringToInt(*daysNeeded));
		Assert::AreEqual(0,Utilities::stringToInt(*hrsNeeded));
		Assert::AreEqual(1,Utilities::stringToInt(*minsNeeded));

		// Freeslot Powersearch with no parameters
		// Tested: h defaults to 1 hour
		userInput = "for";
		searchParameters = p->parseSearchParameters(userInput);
		for (curr=holder.begin(),param=searchParameters.begin(); curr!=holder.end(); curr++,param++) {
			*curr = *param;
		}
		Assert::AreEqual(std::string(""),*searchPhrase);
		Assert::AreEqual(today,Utilities::stringToInt(*startDate));
		Assert::AreEqual(TIME_NOT_SET,Utilities::stringToInt(*startTime));
		Assert::AreEqual(defaultEndDate,Utilities::stringToInt(*endDate));
		Assert::AreEqual(2359,Utilities::stringToInt(*endTime));
		Assert::AreEqual(0,Utilities::stringToInt(*daysNeeded));
		Assert::AreEqual(1,Utilities::stringToInt(*hrsNeeded));
		Assert::AreEqual(0,Utilities::stringToInt(*minsNeeded));

		// Searchphrase PowerSearch with attempted Freeslot Powersearch
		// Tested: Searchphrase PowerSearch takes precedence over Freeslot Powersearch
		userInput = "lecture for 1 d 1 m";
		searchParameters = p->parseSearchParameters(userInput);
		for (curr=holder.begin(),param=searchParameters.begin(); curr!=holder.end(); curr++,param++) {
			*curr = *param;
		}
		Assert::AreEqual(std::string("lecture"),*searchPhrase);
		Assert::AreEqual(today,Utilities::stringToInt(*startDate));
		Assert::AreEqual(TIME_NOT_SET,Utilities::stringToInt(*startTime));
		Assert::AreEqual(defaultEndDate,Utilities::stringToInt(*endDate));
		Assert::AreEqual(2359,Utilities::stringToInt(*endTime));
		Assert::AreEqual(0,Utilities::stringToInt(*daysNeeded));
		Assert::AreEqual(0,Utilities::stringToInt(*hrsNeeded));
		Assert::AreEqual(0,Utilities::stringToInt(*minsNeeded));
	}

	};
}
```
###### TaskSharkTests\UtilitiesTest.cpp
``` cpp

#include "stdafx.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace TaskSharkTests {
	TEST_CLASS(UtilitiesTest) {
public:
	TEST_CLASS_INITIALIZE(StartTestClass) {
		TsLogger::getInstance()->clearLog();
	}

	TEST_METHOD_CLEANUP(EndTestMethod) {
		TsLogger::getInstance()->log(SYS,"Test ended\n");
	}

	TEST_METHOD(Utilities_fieldVecToString) {
		std::string expectedString = "name : -: LABELS_CLEAR star unstar from at to FIELD_END_TIME FIELD_INVALID";
		std::vector<FieldType> fields;
		fields.push_back(NAME);
		fields.push_back(LABELS_ADD);
		fields.push_back(LABELS_DELETE);
		fields.push_back(LABELS_CLEAR);
		fields.push_back(PRIORITY_SET);
		fields.push_back(PRIORITY_UNSET);
		fields.push_back(START_DATE);
		fields.push_back(START_TIME);
		fields.push_back(END_DATE);
		fields.push_back(END_TIME);
		fields.push_back(INVALID_FIELD);
		Assert::AreEqual(expectedString,Utilities::fieldVecToString(fields));
	}

	TEST_METHOD(Utilities_vecToString) {
		std::string expectedString = "little brown fox";
		std::string userInput = "little brown fox";
		std::vector<std::string> inputString = Utilities::stringToVec(userInput);
		Assert::AreEqual(expectedString,Utilities::vecToString(inputString));
	}

	TEST_METHOD(Utilities_equalsIgnoreCase) {
		bool isTrue;

		isTrue = Utilities::equalsIgnoreCase("Hi", "high");
		Assert::AreEqual(false, isTrue);

		isTrue = Utilities::equalsIgnoreCase("hi", "thIgh");
		Assert::AreEqual(false, isTrue);

		isTrue = Utilities::equalsIgnoreCase("high", "high");
		Assert::AreEqual(true, isTrue);

		isTrue = Utilities::equalsIgnoreCase("hi", "h1gh");
		Assert::AreEqual(false, isTrue);

		isTrue = Utilities::equalsIgnoreCase("thigh", "high");
		Assert::AreEqual(false, isTrue);
	}

	TEST_METHOD(Utilities_removeSpaces) {
		std::string expectedString = "add";
		std::string userInput = " add ";
		Assert::AreEqual(expectedString,Utilities::removeSpaces(userInput));
	}

	TEST_METHOD(Utilities_replace) {
		std::string expectedString = "substring";
		std::string a = "parentstring";
		std::string b = "parent";
		std::string c = "sub";
		Assert::AreEqual(expectedString,Utilities::replace(a,b,c));

		expectedString = "\\\\string";
		a = "/string";
		b = "/";
		c = "\\\\";
		Assert::AreEqual(expectedString,Utilities::replace(a,b,c));
	}

	TEST_METHOD(Utilities_getDate) {
		// year removed if same as present year
		int date = 151101;
		std::string expectedDate = "1/Nov";
		Assert::AreEqual(expectedDate,Utilities::toDisplayDate(date));

		// Boundary value : end of year and next year
		date = 151231;
		expectedDate = "31/Dec";
		Assert::AreEqual(expectedDate,Utilities::toDisplayDate(date));

		date = 160101;
		expectedDate = "1/Jan/16";
		Assert::AreEqual(expectedDate,Utilities::toDisplayDate(date));
	}

	TEST_METHOD(Utilities_getTime) {
		int time = 900;
		std::string expectedTime = "9.00 am";
		Assert::AreEqual(expectedTime,Utilities::toDisplayTime(time));

		time = 1800;
		expectedTime = "6.00 pm";
		Assert::AreEqual(expectedTime,Utilities::toDisplayTime(time));

		// Boundary value : transition between am and pm
		time = 1200;
		expectedTime = "12.00 pm";
		Assert::AreEqual(expectedTime,Utilities::toDisplayTime(time));

		time = 0;
		expectedTime = "12.00 am";
		Assert::AreEqual(expectedTime,Utilities::toDisplayTime(time));

	}

	};
}
```
