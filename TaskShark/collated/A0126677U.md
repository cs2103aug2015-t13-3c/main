# A0126677U
###### TaskSharkInternal\Update.cpp
``` cpp

#include "stdafx.h"
#include "Update.h"

Update::Update(std::vector<DisplayedTask>* tasksToDisplay,
			   std::vector<Task>* currentView ) {
				   this->tasksToDisplay = tasksToDisplay;
				   this->currentView = currentView;
}

Update::~Update() {
	if (tasksToDisplay != nullptr) {
		delete tasksToDisplay;
	}
}

void Update::update() {
	tasksToDisplay->clear();
	std::vector<Task>::iterator i = currentView->begin();
	while (i!=currentView->end()) {
		DisplayedTask task;
		task.label = i->getLabelString();
		task.description = i->getName();
		task.date = i->getDisplayDate();
		task.time = i->getDisplayTime();
		task.status = NORMAL;
		if (i->getPriorityStatus()) {
			task.status = PRIORITY;
		}
		if (i->isUrgent()) {
			task.status = URGENT;
		}
		if (i->getDoneStatus()) {
			task.status = PAST;
		}
		task.type = i->getType();
		tasksToDisplay->push_back(task);
		++i;
	}
}
```
###### TaskSharkInternal\Update.h
``` h

enum TaskStatus {
	NORMAL,
	PRIORITY,
	URGENT,
	PAST
};

struct DisplayedTask {
	std::string description;
	std::string label;
	std::string date;
	std::string time;
	TaskStatus status;
	TaskType type;
}; 

class Update {
protected:
	std::vector<Task>* currentView;
	std::vector<DisplayedTask>* tasksToDisplay;

public:
	Update(std::vector<DisplayedTask>* tasksToDisplay,std::vector<Task>* currentView);
	~Update();
	void update();
};

```
###### TaskSharkInternal\Utilities.cpp
``` cpp
//==================================================
//           STRING-FOR-DISPLAY FORMATTERS
//==================================================

std::string Utilities::toDisplayDate(int date) {
	assert(time != 0);
	int localYear = getLocalYear(); 
	int day = date % 100;
	int month = (date % 10000)/100;
	int year = date/10000;

	std::string d = std::to_string(day) + "/" + monthToString((Month)month);
	if (year != localYear) {
		d = d + "/" + std::to_string(year);
	}
	return d;
}

std::string Utilities::toDisplayTime(int time) {
	assert(time >= 0);
	double time2;
	std::stringstream stream;
	std::string amOrPm;
	if (time < 1200) {
		if (time == 0) {
			time = 1200;
		}
		amOrPm = " am";
	} else {
		if (time > 1259) {
			time = time - 1200;
		}
		amOrPm = " pm";
	}	
	time2 = time/100.0;
	stream << std::fixed << std::setprecision(2) << time2;
	return stream.str() + amOrPm;
}

int Utilities::getLocalDay() {
	time_t t = time(nullptr); 
	struct tm now;
	localtime_s(&now,&t);
	return now.tm_mday;
}

int Utilities::getLocalMonth() {
	time_t t = time(nullptr); 
	struct tm now;
	localtime_s(&now,&t);
	return now.tm_mon + 1;
}

int Utilities::getLocalYear() {
	time_t t = time(nullptr); 
	struct tm now;
	localtime_s(&now,&t);
	return now.tm_year - 100;
}
```
###### TaskSharkInternal\Utilities.h
``` h
	static int			getLocalDay();
	static int			getLocalMonth();
	static int			getLocalYear(); // Returns last 2 digits of the year (Eg. 15 for 2015)
	static std::string	toDisplayDate(int date);
	static std::string	toDisplayTime(int time);
};

#endif
```
###### TaskSharkTests\TaskTest.cpp
``` cpp

#include "stdafx.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace TaskSharkTests {
	TEST_CLASS(UnitTest) {
public:

	// Task::getDisplayDate should return a string in:
	// DD/MMM format if the date is the present year
	// DD/MMM/YY format if the date is next year onwards
	TEST_METHOD(Task_getDate_getDisplayTime) {
		Task task;

		// Task with 1 single date 
		int startDate = 151120;
		int endDate = 151120;
		int startTime; 
		int endTime;
		std::string expectedDate = "20/Nov";
		std::string expectedTime = "";
		task.setStartDate(startDate);
		task.setEndDate(endDate);
		Assert::AreEqual(expectedDate,task.getDisplayDate());
		Assert::AreEqual(expectedTime,task.getDisplayTime());

		// Task with 2 different date
		endDate = 151130;
		expectedDate = "20/Nov - 30/Nov";
		task.setEndDate(endDate);
		Assert::AreEqual(expectedDate,task.getDisplayDate());
		Assert::AreEqual(expectedTime,task.getDisplayTime());

		// Task with dates spanning different year
		endDate = 160120;
		expectedDate = "20/Nov - 20/Jan/16";
		task.setEndDate(endDate);
		Assert::AreEqual(expectedDate,task.getDisplayDate());
		Assert::AreEqual(expectedTime,task.getDisplayTime());

		// Task with 1 single time
		startDate = DATE_NOT_SET;
		endDate = DATE_NOT_SET;
		startTime = TIME_NOT_SET;
		endTime = 1800;
		task.setStartDate(startDate);
		task.setEndDate(endDate);
		task.setStartTime(startTime);
		task.setEndTime(endTime);
		expectedDate = "";
		expectedTime = "6.00 pm";
		Assert::AreEqual(expectedDate,task.getDisplayDate());
		Assert::AreEqual(expectedTime,task.getDisplayTime());

		// Task with 2 different time
		startTime = 1500;
		task.setStartTime(startTime);
		expectedDate = "";
		expectedTime = "3.00 pm - 6.00 pm";
		Assert::AreEqual(expectedDate,task.getDisplayDate());
		Assert::AreEqual(expectedTime,task.getDisplayTime());

		// Task with 2 differnt date and time
		startDate = 151120;
		endDate = 151123;
		task.setStartDate(startDate);
		task.setEndDate(endDate);
		expectedDate = "20/Nov - 23/Nov";
		Assert::AreEqual(expectedDate,task.getDisplayDate());
		Assert::AreEqual(expectedTime,task.getDisplayTime());
	}

	};
}
```
###### TaskSharkUI\CommandHistory.cpp
``` cpp

#include "UI.h"

using namespace UserInterface;

// Pushes the userInput into the CommandHistory List

void UI::addCommandHistory() {
	inputHistory->Insert(0,input->Text);
	inputHistoryCount = 0;
}

// Retrieves the previous command the user entered and place it into input textbox

void UI::toPreviousCommand() {
	assert(inputHistoryCount >= 0);
	if (inputHistoryCount < inputHistory->Count) {
		input->Text = inputHistory[inputHistoryCount];
		if (inputHistoryCount != inputHistory->Count -1) {
			++inputHistoryCount;
		}
	}
}

// while going through the previous commands the user entered, this function
// changes the input textbox text to one step forward from the past command the
// user is currently at

void UI::toNextCommand() {
	assert(inputHistoryCount >= 0);
	if (inputHistoryCount <= inputHistory->Count) {
		if (inputHistoryCount != 0) {
			--inputHistoryCount;
			input->Text = inputHistory[inputHistoryCount];
		} else {
			input->Text = "";
		}
	}
}
```
###### TaskSharkUI\Dropdown.cpp
``` cpp

#include "UI.h"

using namespace UserInterface;

// If the selected index in the dropdown menu is not the last item,
// move the selection to the next item

void UI::incrementDropCount() {
	assert(dropDown->DroppedDown);
	if (dropDown->SelectedIndex + 1 < dropDown->Items->Count) {
		dropDown->SelectedIndex++;		
	}
}

void UI::decrementDropCount() {
	if (dropDown->SelectedIndex > 0 ) {
		dropDown->SelectedIndex--;
	} else {
		dropDown->DroppedDown = false;
	}
}

// copies the selected item in the dropdown menu into the userInput textbox, 
// and closes the dropdown menu.

bool UI::acceptAutosuggest() {
	assert(dropDown->DroppedDown);
	if (dropDown->SelectedIndex > -1) {
		String^ command = dropDown->SelectedItem->ToString();
		input->Clear();
		input->Text = command;
		selectFields();	
		dropDown->DroppedDown = false;
		return true;
	}
	dropDown->DroppedDown = false;
	return false;
}

// Loops through the list of command keywords, if the first few characters of 
// a certain keyword is matched, activates the dropdown menu with a list of 
// items corresponding to the command 

void UI::commandAutoComplete() {
	bool found = false;
	for each(String^ command in keywords) {
		if (command == FROM || String::IsNullOrEmpty(input->Text) ) {
			break;
		}
		if (matchKeyword(command)) {
			showSuggestedCommands(command);
			found = true;
			dropDown->DroppedDown = true;
			break;
		}
	}
	if (!found) {
		dropDown->DroppedDown = false;
	}
}

// Populates the dropdown menu with the command patterns corresponding to the
// keyword passed in

void UI::showSuggestedCommands(String^ keyword) {
	dropDown->Items->Clear();
	if (suggestions[keyword] == nullptr) {
		return;
	} else if (suggestions[keyword]->GetType() == keyword->GetType()) {
		dropDown->Items->Add(suggestions[keyword]);
	} else {
		List<String^>^ commands = dynamic_cast<List<String^>^>(suggestions[keyword]);
		for each(String^ command in commands) {
			dropDown->Items->Add(command);
		}
	}
}

// Performs a character by character comparison of the Command keyword
// and the text in input textbox, returns:
// TRUE  - if one or more characters match the sequence 
// FALSE - otherwise

bool UI::matchKeyword(String^ keyword) {
	String^ inputText = input->Text;
	int inputLength = input->Text->Length;
	int keywordLength = keyword->Length;
	int i=0;
	while (i < inputLength && i<keywordLength) {
		if (inputText[i] == ' ' && i != 0) {
			return false;
		}
		if (inputText[i] != keyword[i]) {
			return false;
		}
		++i;
	}
	return true;
}

// Parses the text in input textbox, highlights the nearest parameter with 
// the format : <.....>

void UI::selectFields() {
	int i=0;
	int length = input->Text->Length;
	int start;
	int end;
	bool found = false;
	String^ text = input->Text;
	while (i < length) {
		if (text[i] == '<') {
			start = i;
		}
		if (text[i] == '>') {
			end = i+1;
			found = true;
			break;
		}
		++i;
	}
	if (found) {
		input->Select(start,end-start);
	} else {
		input->Select(length,1);
	}
}

```
###### TaskSharkUI\Execute.cpp
``` cpp

#include "UI.h"

using namespace UserInterface;

String^ UI::wrapWord(std::string content) {
	unsigned int width;
	if (tileView) {

	} else {
		width = 45;
	}
	if (content.size() > width) {
		unsigned int i=width-1;
		while (content[i] != ' ' && i != 0) {
			--i;
		}
		if (i == 0) {
			i = width-1;
		}
		content.insert(i,"\r\n");
	}
	return gcnew String(content.c_str());
}

// Renders the help image invisible and bring the component to the back of form 

void UI::closeHelpMode() {
	helpMode = false;
	help->Visible = false;
	help->SendToBack();
	input->Clear();
	feedback->Clear();
}

// Gets the tabIndex from logic that UI should display to the user

int UI::getTabIndex() {
	mode = logic->getMode();
	assert(mode >= 0 && mode < 8);
	int tabIndex = 0;
	switch (mode) {
	case HOME:
		tabIndex = HOME;
		break;
	case ALL:
		tabIndex = ALL;
		break;
	case TODAY:
		tabIndex = TODAY;
		break;
	case WEEK:
		tabIndex = WEEK;
		break;
	case EVENTS:
		tabIndex = EVENTS;
		break;
	case DEADLINES:
		tabIndex = DEADLINES;
		break;
	case FLOATINGS:
		tabIndex = FLOATINGS;
		break;
	case SEARCHES:
		tabIndex = SEARCHES;
		break;
	case PAST_:
		tabIndex = PAST_;
		break;
	}
	return tabIndex;
}

void UI::updateTable(TabPage^ currentTab) {
	bool todoDiscovered = false;
	bool eventDiscovered = false;
	bool floatingDiscovered = false;
	display->Rows->Clear();
	unsigned int size = tasks->size();
	int j = 0;
	for(unsigned int i=0 ; i< size ; ++i) {
		DisplayedTask task = (*tasks)[i];
		String^ index = (i+1).ToString();
		String^ label = gcnew String(task.label.c_str());
		String^ title = wrapWord(task.description);
		String^ d = gcnew String(task.date.c_str());
		String^ t = gcnew String(task.time.c_str());	

		if(!todoDiscovered && task.type == TODO) {
			todoDiscovered = true;
			display->Rows->Add("","","","","");
			display->Rows->Add("","","Todo","","");
			display->Rows[i+j+1]->DefaultCellStyle->BackColor = ColorTranslator::FromHtml("#FF6666");
			j += 2;
		} else if(!eventDiscovered && task.type == EVENT) {
			eventDiscovered = true;
			display->Rows->Add("","","","","");
			display->Rows->Add("","","Events","","");
			display->Rows[i+j+1]->DefaultCellStyle->BackColor = ColorTranslator::FromHtml("#FFB84D");
			j += 2;
		} else if(!floatingDiscovered && task.type == FLOATING) {
			floatingDiscovered = true;
			display->Rows->Add("","","","","");
			display->Rows->Add("","","Floating","","");
			display->Rows[i+j+1]->DefaultCellStyle->BackColor = ColorTranslator::FromHtml("#B9FF2D");
			j += 2;
		}
		display->Rows->Add(index,label,title,d,t);
		if(task.status == PRIORITY) {
			display->Rows[i+j]->DefaultCellStyle->ForeColor = Color::Blue;
		} else if(task.status == URGENT) {
			display->Rows[i+j]->DefaultCellStyle->ForeColor = Color::Red;
		} else if(task.status == PAST) {
			display->Rows[i+j]->DefaultCellStyle->ForeColor = Color::Gray;
		}
		if(i == size-1) {
			display->Rows->RemoveAt(0);
		}
	}
	if(size > 0) {
		display->Rows[0]->Selected = false;
		display->FirstDisplayedScrollingRowIndex = 0;
	}
	currentTab->Controls->Add(display);
}

void UI::updateDisplay() {
	int tabIndex = getTabIndex();
	tabs->SelectTab(tabIndex);
	TabPage^ currentTab = tabs->SelectedTab;
	currentTab->Controls->Clear();
	if (tileView) {
		addTilesToTab(currentTab);
	} else {
		updateTable(currentTab);
	}
	input->Focus();
}

void UI::addTilesToTab(TabPage^ currentTab) {
	int x = 0;
	int y = 0;
	int width = currentTab->Width;
	int height = currentTab->Height;
	int squareTileWidth = (width/5)-10;
	int longTileWidth = (width*2/5)-15;
	int tileHeight = (height/5)-5;
	unsigned int size = tasks->size();
	for (unsigned int i=0; i< size; ++i) {
		DisplayedTask task = (*tasks)[i];
		String^ index = (i+1).ToString() + "\r\n";
		String^ label = "\r\n";
		if (task.label != "") {
			label = "[" + gcnew String(task.label.c_str()) + "]" + label;
		}
		String^ title = gcnew String(task.description.c_str()) + "\r\n";
		String^ d = gcnew String(task.date.c_str()) + "\r\n";
		String^ t = gcnew String(task.time.c_str()) + "\r\n";		

		MetroTile^ tile = gcnew MetroTile();
		tile->ActiveControl = nullptr;
		tile->TabStop = false;
		tile->Style = this->Style;
		tile->Name = tile + i.ToString();
		if (title->Length <= 10) {
			index = "";
			tile->TileCount = i+1;
		}
		tile->TextAlign = System::Drawing::ContentAlignment::TopLeft;
		tile->TileTextFontWeight = MetroFramework::MetroTileTextWeight::Regular;
		if (task.status == PRIORITY) {
			tile->Style = MetroFramework::MetroColorStyle::Purple;
		} else if (task.status == URGENT) {
			tile->Style = MetroFramework::MetroColorStyle::Red;
		} else if (task.status == PAST) {
			tile->Style = MetroFramework::MetroColorStyle::Silver;
		}
		else {
			if (task.type == FLOATING) {
				tile->Style = MetroFramework::MetroColorStyle::Lime;
			}
		}	
		String^ tileText = index + title + label + d + t;
		tile->Text = tileText;
		if (task.type == EVENT || title->Length > 20) {
			tile->Size = System::Drawing::Size(longTileWidth,tileHeight);
		} else {
			tile->Size = System::Drawing::Size(squareTileWidth,tileHeight);	
		}
		if (tile->Width > 140 && x%5 == 4) {
			++x;
			++y;
		}
		tile->Location = System::Drawing::Point((x%5*(squareTileWidth+5))+17, (y/5*(height/5))+5);
		currentTab->Controls->Add(tile);
		++x;
		++y;
		if (tile->Width > 140) {
			++x;
			++y;
		}

	}	
}

// Reads the characters from textbox
// Converts the entire input from CLI String to std::string
// Stores the input into class variable

void UI::getInput() {
	msclr::interop::marshal_context context;
	userInput = new std::string(context.marshal_as<std::string>(input->Text));
}

// Passes UserInput to Logic
// prints feedback message :
//	[GREEN] - command successfully processed
//  [RED]	- exception caught, invalid command
// updates current display of task 
// If the input is "help", does not call logic, it will show help page within UI

void UI::processAndExecute() {
	feedback->Clear();
	std::string message;
	if (input->Text == "help") {
		helpMode = true;
		help->Visible = true;
		help->BringToFront();
		feedback->ForeColor = Color::Green;
		printFeedBackMessage(" press any key to exit help");
		return;
	}
	try {
		message = logic->processCommand(*userInput);
		feedback->ForeColor = Color::Green;
		updateDisplay();
		if (userInput != nullptr) {
			delete userInput;
			userInput = nullptr;
		}
	} catch(std::exception e) {
		feedback->ForeColor = Color::Red;
		message = std::string(e.what()) + "\t(enter \"help\" for command formats)";
	}
	printFeedBackMessage(" " + message);
}

// Channels output of "message" to feedback textbox

void UI::printFeedBackMessage(std::string message) {
	feedback->Text = gcnew String(message.c_str());
}

// Decrements the first displayed row index of the table to simulate scrolling

void UI::scrollDown() {
	if(display->FirstDisplayedScrollingRowIndex < display->RowCount )
		display->FirstDisplayedScrollingRowIndex = 
		display->FirstDisplayedScrollingRowIndex + 1;
}

// Increments the first displayed row index of the table to simulate scrolling

void UI::scrollUp() {
	if(display->FirstDisplayedScrollingRowIndex > 0 )
		display->FirstDisplayedScrollingRowIndex = 
		display->FirstDisplayedScrollingRowIndex - 1;
}

// Updates the date display every 5 seconds

System::Void UI::updateCurrentTime_Tick(System::Object^ sender, System::EventArgs^ e) {
	DateTime localDateTime = DateTime::Now;
	String^ month = gcnew String(Utilities::monthToString((Month)localDateTime.Month).c_str());
	String^ t = (localDateTime.DayOfWeek).ToString() + " " + 
		(localDateTime.Day).ToString() + "/" + month;

	currentTime->Text = t;
}
```
###### TaskSharkUI\Keypress.cpp
``` cpp

#include "UI.h"

using namespace UserInterface;

// This function is activated whenever a key is released
// Response to different keys :
// 1. [ALL]  - if helpMode is activated, helpMode will be disabled
// 2. [HOME] - ignore the key
// 3. [ESC]  - minimize window
// 4. [TAB]  - if dropdown box is active, increments the selection index, else
//				check if the input textbox has parameters from autosuggest, and 
//				highlights the nearest field.
// 5. All keys except [UP], [DOWN], [RETURN] :
//			 - performs autosuggest

System::Void UI::input_KeyUp (
	System::Object^ sender,
	System::Windows::Forms::KeyEventArgs^ e) {

		Keys key = e->KeyCode;
		if (e->KeyCode == Keys::Home) {
			// Do nothing 
			return;
		}
		if (key == Keys::Tab) {
			if (dropDown->DroppedDown) {
				incrementDropCount();
			} else {
				selectFields();
			}
			return;
		}
		if (key != Keys::Up && key != Keys::Down && key != Keys::Return) {
			commandAutoComplete();
			// Unstable:
			// highlightSyntax();
			return;
		}
}

// This function is activated whenever a key is pressed
// Response to different keys :
// 1. [RETURN] - if the dropdown menu is active, sets the input textbox to be 
//				 the item selected in the dropdown menu
//				 else, accepts the input textbox text as command and process it
// 2. [DOWN]   - if the dropdown menu is active, selected the next item in the
//				 dropdown menu, else if the user is currently going through 
//				 the previous entered commands, move one step forward
// 3. [UP]	   - if the dropdown menu is active, selected the previous item in 
//				 the dropdown menu, else if the user is currently going through 
//				 the previous entered commands, move one step backward

System::Void UI::input_KeyDown(
	System::Object^ sender,
	System::Windows::Forms::KeyEventArgs^ e) {

		Keys key = e->KeyCode;	
		if (helpMode) {
			closeHelpMode();
			return;
		}
		if (key == Keys::Return) { 
			if (input->Text == "s") {
				if (tileView) {
					tileView = false;
				} else {
					tileView = true;
				}
				updateDisplay();
				input->Clear();
				return;
			}
			if (dropDown->DroppedDown) {
				if (acceptAutosuggest()) {
					return;
				}
			}
			getInput();
			processAndExecute();
			addCommandHistory();
			input->Clear();
			return; 
		}
		if (key == Keys::Down) {
			if (dropDown->DroppedDown) {
				incrementDropCount();
			} else {
				toNextCommand();
			}
			return;
		}
		if (key == Keys::Up) {
			if (dropDown->DroppedDown) {
				decrementDropCount();
			} else {
				toPreviousCommand();
			}
			return;
		}
}

System::Void UI::tabs_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e) {
	DisplayMode index = (DisplayMode)tabs->SelectedIndex;
	switch (index) {
	case HOME:
		input->Text = "view home";
		break;
	case ALL:
		input->Text = "view all";
		break;
	case TODAY:
		input->Text = "view today";
		break;
	case WEEK:
		input->Text = "view week";
		break;
	case EVENTS:
		input->Text = "view events";
		break;
	case DEADLINES:
		input->Text = "view todo";
		break;
	case FLOATINGS:
		input->Text = "view floating";
		break;
	case PAST_:
		input->Text = "view past";
		break;
	}
	getInput();
	processAndExecute();
	input->Clear();
}
System::Void UI::UI_KeyUp(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
	if(e->KeyCode == Keys::Escape) {	
		this->WindowState = FormWindowState::Minimized;
		return;
	}
}
System::Void UI::display_Click(System::Object^  sender, System::EventArgs^  e) {
	input->Focus();
}
System::Void UI::UI_KeyDown(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
	if(e->Shift) {	
		if(e->KeyCode == Keys::Up) {
			scrollUp();
		} else if(e->KeyCode == Keys::Down) {
			scrollDown();
		}
	}
}
```
###### TaskSharkUI\UI.cpp
``` cpp

#include "UI.h"

using namespace System;
using namespace UserInterface;
using namespace System::Windows::Forms;

[STAThread]
int main() {
	Application::EnableVisualStyles();
	Application::SetCompatibleTextRenderingDefault(false);

	UserInterface::UI mainWindow;
	Application::Run(%mainWindow);
	return 0;
}

UI::UI() {
	selectingFields = false;
	helpMode = false;
	tileView = false;
	logger = TsLogger::getInstance();
	InitializeComponent();
	logic = logic->getInstance();
	tasks = new std::vector<DisplayedTask>();
	logic->subscribe(tasks);
	TS::firstLoad = true;
	input->Text = "view home";
	getInput();
	processAndExecute();
	input->Clear();
	tabs->Style = this->Style;
	inputHistoryCount = 0;
	inputHistory = gcnew System::Collections::Generic::List<String^>();
	keywords = gcnew List<String^>();
	keywords->Add(ADD);
	keywords->Add(DEL);
	keywords->Add(MODIFY);
	keywords->Add(SEARCH);
	keywords->Add(UNDO);
	keywords->Add(VIEW);
	keywords->Add(CLEAR);
	keywords->Add(DONE);
	keywords->Add(SAVE);
	keywords->Add(QUIT);
	keywords->Add(HELP);
	keywords->Add(DISPLAY);
	keywords->Add(LOAD);
	keywords->Add(NOTDONE);
	keywords->Add(PICK);
	keywords->Add(REDO);
	keywords->Add(FROM);
	keywords->Add(BY);
	keywords->Add(TO);
	keywords->Add(ON);
	keywords->Add(AT);
	this->help->Image = Image::FromFile(System::AppDomain::CurrentDomain->BaseDirectory + "help.png");
	this->Icon = gcnew System::Drawing::Icon(System::AppDomain::CurrentDomain->BaseDirectory + "shark.ico");
	this->BackImage = Image::FromFile(System::AppDomain::CurrentDomain->BaseDirectory + "shark.ico");

	//*********** ADD command formats ******************
	addCommands = gcnew List<String^>();
	addCommands->Add("add <TASK>");	
	addCommands->Add("add <TODO> by <DATE/TIME>");
	addCommands->Add("add <TODO> by <DATE> at <TIME>");
	addCommands->Add("add <EVENT> on <DATE>");
	addCommands->Add("add <EVENT> on <DATE> at <TIME>");
	addCommands->Add("add <EVENT> on <DATE> from <TIME> to <TIME>");
	addCommands->Add("add <EVENT> from <DATE> to <DATE>");
	addCommands->Add("add <EVENT> from <DATE> at <TIME> to <DATE> at <TIME>");
	addCommands->Add("add <EVENT> from <TIME> to <TIME>");

	//********** VIEW command formats ******************
	viewCommands = gcnew List<String^>();
	viewCommands->Add("view all");
	viewCommands->Add("view today");
	viewCommands->Add("view week");
	viewCommands->Add("view floating");
	viewCommands->Add("view todo");
	viewCommands->Add("view events");
	viewCommands->Add("view past");
	viewCommands->Add("view <LABEL>");
	viewCommands->Add("view after <DATE>");
	viewCommands->Add("view before <DATE>");
	viewCommands->Add("view from <DATE> at <TIME> to <DATE> at <TIME>");

	//********** MODIFY command formats *****************
	modifyCommands = gcnew List<String^>();
	modifyCommands->Add("modify <ID> <DESCRIPTION>");
	modifyCommands->Add("modify <ID> : <LABEL>");
	modifyCommands->Add("modify <ID> from <DATE> at <TIME> to <DATE> at <TIME>");
	modifyCommands->Add("modify <ID> by <NEW DEADLINE>");
	modifyCommands->Add("modify <ID> float");
	modifyCommands->Add("modify <ID> star");
	modifyCommands->Add("modify <ID> unstar");

	//********** SEARCH command formats *****************
	searchCommands = gcnew List<String^>();
	searchCommands->Add("search <TASK DESCRIPTION>");
	searchCommands->Add("search <TASK DESCRIPTION> after <DATE>");
	searchCommands->Add("search <TASK DESCRIPTION> before <DATE>");
	searchCommands->Add("search <TASK DESCRIPTION> from <DATE> at <TIME> to <DATE> at <TIME>");
	searchCommands->Add("search after <DATE> for <NUM> d <NUM> h <NUM> m");
	searchCommands->Add("search before <DATE> for <NUM> d <NUM> h <NUM> m");
	searchCommands->Add("search from <DATE> to <DATE> for <NUM> d <NUM> h <NUM> m");

	//********** PICK command formats *****************
	pickCommands = gcnew List<String^>();
	pickCommands->Add("pick <ID>");
	pickCommands->Add("pick <ID> reserve");

	//********** LOAD command formats *****************
	loadCommands = gcnew List<String^>();
	loadCommands->Add("load <FILEPATH>");
	loadCommands->Add("load from <FILEPATH>");

	//********** SAVE command formats *****************
	saveCommands = gcnew List<String^>();
	saveCommands->Add("save <FILEPATH>");
	saveCommands->Add("save to <FILEPATH>");

	//********** SET command formats *****************
	saveCommands = gcnew List<String^>();
	saveCommands->Add("set welcome <MESSAGE>");
	saveCommands->Add("set <COMMAND KEYWORD> <CUSTOM KEYWORD>");

	suggestions = gcnew Hashtable();
	suggestions->Add(HELP,HELP);
	suggestions->Add(VIEW_HOME,VIEW_HOME);
	suggestions->Add(VIEW_HOME_TS,VIEW_HOME_TS);
	suggestions->Add(QUIT,QUIT);
	suggestions->Add(CLEAR,CLEAR);
	suggestions->Add(DISPLAY,DISPLAY);
	suggestions->Add(UNDO,UNDO);
	suggestions->Add(REDO,REDO);
	suggestions->Add(DEL,"delete <ID>");
	suggestions->Add(DONE,"done <ID>");
	suggestions->Add(NOTDONE,"notdone <ID>");

	suggestions->Add(ADD,addCommands);
	suggestions->Add(MODIFY,modifyCommands);
	suggestions->Add(PICK,pickCommands);
	suggestions->Add(SEARCH,searchCommands);
	suggestions->Add(VIEW,viewCommands);
	suggestions->Add(LOAD,loadCommands);
	suggestions->Add(SAVE,saveCommands);
	suggestions->Add(SET,setCommands);
}

UI::~UI() {
	if(components) {
		delete components;
	}
}

```
###### TaskSharkUI\UI.h
``` h

#pragma once

#include "stdafx.h"
#include "Logic.h"
#include <msclr\marshal_cppstd.h>

// DEFINE KEYWORD STRINGS
#define ADD "add "
#define DEL "delete "
#define MODIFY "modify "
#define SEARCH "search "
#define UNDO "undo"
#define HELP "help"
#define VIEW "view "
#define DONE "done "
#define SAVE "save "
#define CLEAR "clear all"
#define QUIT "exit"
#define FROM " from "
#define BY " by "
#define TO " to "
#define ON " on "
#define AT " at "
#define DISPLAY "display"
#define LOAD "load "
#define NOTDONE "notdone "
#define PICK "pick "
#define REDO "redo"
#define SET "set "
#define VIEW_HOME "home"
#define VIEW_HOME_TS "ts"

namespace UserInterface {

	using namespace System;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Collections::Generic;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;
	using namespace System::Threading;
	using namespace MetroFramework::Forms;
	using namespace MetroFramework::Controls;

	public ref class UI : public MetroForm {

	public:
		UI(void);

	protected:
		~UI();

```
